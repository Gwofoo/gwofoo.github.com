<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客NexT主题配置</title>
    <url>/cl5gc8awq0001ecu9hpo49ase/</url>
    <content><![CDATA[<h1 id="安装NexT"><a href="#安装NexT" class="headerlink" title="安装NexT"></a>安装NexT</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>在Hexo文件夹下，右键<code>Git Bash Here</code>，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>下载zip安装包：<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></p>
<p>管理员解压，文件夹改名为next（全部小写），至themes目录下。</p>
<span id="more"></span>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>官方配置文档</p>
<p><a href="https://hexo.io/zh-cn/docs/configuration.html">配置 | Hexo</a></p>
<p>网上博客</p>
<p><a href="https://www.jianshu.com/p/3a05351a37dc">Hexo的Next主题详细配置</a></p>
<p><a href="https://www.jianshu.com/p/b20fc983005f">Hexo设置主题以及Next主题个性设置</a></p>
<h2 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h2><p>打开<strong>生成的Hexo目录\themes\next/layout/_layout.swig文件</strong>，在 &lt; /body&gt;上面添加代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>打开主题配置文件，在里面添加如下代码（可以放在最后面）：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># background settings</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># add canvas-nest effect</span></span><br><span class="line"><span class="comment"># see detail from https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h2><p>参考文章：</p>
<p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93670772">Hexo博客NexT主题下添加字数统计和阅读时长</a></p>
<p>安装<code>hexo-symbols-count-time</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件添加如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure>
<p>在NexT主题配置文件添加如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>     <span class="comment"># 是否另起一行（true的话不和发表时间等同一行）</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>     <span class="comment"># 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span>   <span class="comment"># 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span>                   <span class="comment"># Average Word Length</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span>                 <span class="comment"># Words Per Minute（每分钟阅读词数）</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">mins.</span></span><br></pre></td></tr></table></figure>
<h2 id="添加文章更新时间"><a href="#添加文章更新时间" class="headerlink" title="添加文章更新时间"></a>添加文章更新时间</h2><p>主题配置文件下，<code>updated_at</code> 的属性改为 <code>true</code> 即可。</p>
<h2 id="设置代码高亮主题"><a href="#设置代码高亮主题" class="headerlink" title="设置代码高亮主题"></a>设置代码高亮主题</h2><p>NexT 使用 <a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme</a> 作为代码高亮，共有5款主题供选择。 </p>
<p>默认使用的是 白色的 <code>normal</code> 主题，可选的值有 :</p>
<p><code>normal</code>，<code>night</code>， <code>night blue</code>， <code>night bright</code>， <code>night eighties</code>, 如下图所示：</p>
<p>修改：在NexT下的_config.yml中设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br></pre></td></tr></table></figure>
<h2 id="添加阅读全文按钮"><a href="#添加阅读全文按钮" class="headerlink" title="添加阅读全文按钮"></a>添加阅读全文按钮</h2><p>只需在文章中你想截止的地方添加</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h2><p>1、安装 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fflashlab%2Fhexo-generator-search">hexo-generator-searchdb</a> 插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>2、打开 <strong>站点配置文件</strong> 找到<code>Extensions</code>在下面添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>3、打开 <strong>主题配置文件</strong> 找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code></p>
<h2 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span> </span><br><span class="line">	<span class="attr">url:</span> <span class="comment">#/images/avatar.gif</span></span><br></pre></td></tr></table></figure>
<p>然后将准备好的gif图片放入next/source/images/中即可。</p>
<h2 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h2><p>参考博客链接：</p>
<p><a href="https://www.jianshu.com/p/924b3eea4fa6">hexo-next 添加鼠标点击特效</a></p>
<p>在<em>…\themes\hexo-theme-next\source\js\my_js</em>下新建clicklove.js文件，source后面的路径和文件名都可以自定义，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*网页鼠标点击特效（爱心）*/</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>) </span>&#123;<span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="number">0</span>; e &lt; s.length; e++) s[e].alpha &lt;= <span class="number">0</span> ? (t.body.removeChild(s[e].el), s.splice(e, <span class="number">1</span>)) : (s[e].y--, s[e].scale += <span class="number">.004</span>, s[e].alpha -= <span class="number">.013</span>, s[e].el.style.cssText = <span class="string">&quot;left:&quot;</span> + s[e].x + <span class="string">&quot;px;top:&quot;</span> + s[e].y + <span class="string">&quot;px;opacity:&quot;</span> + s[e].alpha + <span class="string">&quot;;transform:scale(&quot;</span> + s[e].scale + <span class="string">&quot;,&quot;</span> + s[e].scale + <span class="string">&quot;) rotate(45deg);background:&quot;</span> + s[e].color + <span class="string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>) </span>&#123;<span class="keyword">var</span> t = <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> e.onclick &amp;&amp; e.onclick;e.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;t &amp;&amp; t(), o(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">e</span>) </span>&#123;<span class="keyword">var</span> a = t.createElement(<span class="string">&quot;div&quot;</span>);a.className = <span class="string">&quot;heart&quot;</span>, s.push(&#123;<span class="attr">el</span>: a,<span class="attr">x</span>: e.clientX - <span class="number">5</span>,<span class="attr">y</span>: e.clientY - <span class="number">5</span>,<span class="attr">scale</span>: <span class="number">1</span>,<span class="attr">alpha</span>: <span class="number">1</span>,<span class="attr">color</span>: c()&#125;), t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>) </span>&#123;<span class="keyword">var</span> a = t.createElement(<span class="string">&quot;style&quot;</span>);a.type = <span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span> &#123;a.appendChild(t.createTextNode(e))&#125; <span class="keyword">catch</span> (t) &#123;a.styleSheet.cssText = e&#125;t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">&quot;rgb(&quot;</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;,&quot;</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;,&quot;</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> s = [];e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;<span class="built_in">setTimeout</span>(e, <span class="number">1e3</span> / <span class="number">60</span>)&#125;, i(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>), n(), r()&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
<p>在<em>…\themes\hexo-theme-next\layout\</em>路径下找到<em>“_layout.swig”</em>文件，在<head></head>标签中引入新建的js文件，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/my_js/clicklove.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="本站运行时间"><a href="#本站运行时间" class="headerlink" title="本站运行时间"></a>本站运行时间</h2><p>在<code>/next/layout/_partials/footer.swig</code>在自己喜欢的位置（比如在<code>&lt;div class=&quot;copyright&quot;&gt;.....&lt;/div&gt;</code>这个标签下）加上如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); </span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">createtime</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> birth= <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;7/2/2019 23:12:45&quot;</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间 </span></span></span><br><span class="line"><span class="javascript">        this_year = now.getFullYear();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> anniversary = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;7/2/2019 23:12:45&quot;</span>).setFullYear(this_year);</span></span><br><span class="line"><span class="javascript">        now.setTime(now.getTime()+<span class="number">250</span>); </span></span><br><span class="line"><span class="javascript">        years = this_year - <span class="number">2019</span>;</span></span><br><span class="line"><span class="javascript">        days = (now - anniversary ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="built_in">Math</span>.floor(days); 			</span></span><br><span class="line"><span class="javascript">        hours = (now - anniversary ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="built_in">Math</span>.floor(hours); </span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">String</span>(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - anniversary ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum); </span></span><br><span class="line"><span class="javascript">        mnum = <span class="built_in">Math</span>.floor(minutes); <span class="keyword">if</span>(<span class="built_in">String</span>(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125; </span></span><br><span class="line"><span class="javascript">        seconds = (now - anniversary ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum); </span></span><br><span class="line"><span class="javascript">        snum = <span class="built_in">Math</span>.round(seconds); <span class="keyword">if</span>(<span class="built_in">String</span>(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;timeDate&quot;</span>).innerHTML = <span class="string">&quot;本站已安全运行 &quot;</span> + years + <span class="string">&quot; 年 &quot;</span> + dnum + <span class="string">&quot; 天 &quot;</span>; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;times&quot;</span>).innerHTML = hnum + <span class="string">&quot; 小时 &quot;</span> + mnum + <span class="string">&quot; 分 &quot;</span> + snum + <span class="string">&quot; 秒&quot;</span>; </span></span><br><span class="line"><span class="javascript">    &#125; </span></span><br><span class="line"><span class="javascript">    <span class="built_in">setInterval</span>(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="博客插入图片"><a href="#博客插入图片" class="headerlink" title="博客插入图片"></a>博客插入图片</h2><p>安装插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure>
<p>在Hexo的<code>config.yaml</code>中更改配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span>  <span class="comment">#当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>之后就可以在使用<code>![](xxx.jpg)</code>的方式愉快的插入图片了。不过，需要事先将图片<code>xxx.jpg</code>存入博客同名的文件夹。</p>
<h3 id="与Typora结合"><a href="#与Typora结合" class="headerlink" title="与Typora结合"></a>与Typora结合</h3><p>粘贴图片到Typora时，可以自动保存到目标文件夹。不必事先保存图片。</p>
<p>设置方式：</p>
<p>在Typora中找到<code>文件-&gt;偏好设置-&gt;图像</code>，将“插入图片时…”选项改为“复制到指定路径：./${filename}”，并可勾选前三个选项。</p>
<p>但是这样的话图片路径实际上是<code>文件名/图片名.jpg</code>，而不是<code>/图片名.jpg</code>。所以等写完博客后，再用Ctrl+H做一个全局替换。</p>
<p><img src="image-20210927151925284.png" alt="image-20210927151925284"></p>
<h2 id="支持LaTeX"><a href="#支持LaTeX" class="headerlink" title="支持LaTeX"></a>支持LaTeX</h2><p>Hexo默认的渲染引擎是marked，不支持mathjax，所以需要更换Hexo的渲染引擎为hexo-renderer-kramed：</p>
<h3 id="安装Kramed"><a href="#安装Kramed" class="headerlink" title="安装Kramed"></a>安装Kramed</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<h3 id="更改文件配置"><a href="#更改文件配置" class="headerlink" title="更改文件配置"></a>更改文件配置</h3><p>打开<code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code><br>将：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Fit kramed&#x27;s rule: $$ + \1 + $$</span></span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/`\$(.*?)\$`/g</span>, <span class="string">&#x27;$$$$$1$$$$&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="停用hexo-math并安装mathjax"><a href="#停用hexo-math并安装mathjax" class="headerlink" title="停用hexo-math并安装mathjax"></a>停用hexo-math并安装mathjax</h3><p>卸载hexo-math</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>
<p>安装hexo-renderer-mathjax</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>
<h3 id="更新Mathjax配置文件"><a href="#更新Mathjax配置文件" class="headerlink" title="更新Mathjax配置文件"></a>更新Mathjax配置文件</h3><p>打开<code>/node_modules/hexo-renderer-mathjax/mathjax.html</code><br>将最后一行的<code>&lt;script&gt;</code>改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="更改默认转义规则"><a href="#更改默认转义规则" class="headerlink" title="更改默认转义规则"></a>更改默认转义规则</h3><p>因为LaTeX与markdown语法有语义冲突，所以 hexo 默认的转义规则会将一些字符进行转义，所以我们需要对默认的规则进行修改.<br>打开<code>/node_modules\kramed\lib\rules\inline.js</code><br>更改后为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<h3 id="开启mathjax"><a href="#开启mathjax" class="headerlink" title="开启mathjax"></a>开启mathjax</h3><p>打开主题目录下的config.yml文件（注意这里是所使用主题的yml文件，不是hexo的yml文件）<br>搜索mathjax，将enable设为true。</p>
<p>并且写博客的时候需要开启Latex就需要加上头开启<code>Mathjax: true</code></p>
]]></content>
      <categories>
        <category>Hexo建站</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ-大数整除</title>
    <url>/cl5gc8awy0003ecu98kpa27s0/</url>
    <content><![CDATA[<h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="http://www.dotcpp.com/oj/problem1074.html">http://www.dotcpp.com/oj/problem1074.html</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定理：把一个至少两位的正整数的个位数字去掉，再从余下的数中减去个位数的5倍。当且仅当差是17的倍数时，原数也是17的倍数 。</p>
<p>例如，34是17的倍数，因为3-20=-17是17的倍数；201不是17的倍数，因为20-5=15不是17的倍数。输入一个正整数n，你的任务是判断它是否是17的倍数。</p>
<span id="more"></span>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1&lt;=n&lt;=10^100），表示待判断的正整数。n=0表示输入结束，你的程序不应当处理这一行。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出一行，表示相应的n是否是17的倍数。1表示是，0表示否。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>34<br>201<br>2098765413<br>1717171717171717171717171717171717171717171717171718<br>0</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>1<br>0<br>1<br>0</p>
<h2 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h2><p>不要用这个定理，否则要处理大数会很麻烦。 直接用小学列式除法的原理，从高位到低位依次读入数字，得到每一次的余数r （r中刷新地保存每次的余数），直到大数所有位数被读一遍。最后判断r是否为0，为0则说明刚好被17整除。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; str) &#123; <span class="comment">//读入这个大数（2345</span></span><br><span class="line">		<span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//为0则退出</span></span><br><span class="line">		<span class="keyword">int</span> m, r=<span class="number">0</span>;  <span class="comment">//m表示每一次的被除数，r表示每一次的余数</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++) &#123;  <span class="comment">//遍历这个大数</span></span><br><span class="line">			m = r*<span class="number">10</span> + str[i] - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//（2,23,64,135</span></span><br><span class="line">			r = m % <span class="number">17</span>;  <span class="comment">//（2,6,13,16</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (r) cout &lt;&lt; <span class="string">&#x27;0&#x27;</span> &lt;&lt; endl;  <span class="comment">//r不为0，不能被17整除</span></span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&#x27;1&#x27;</span> &lt;&lt; endl;    <span class="comment">//r为0，能被17整除</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch学习笔记</title>
    <url>/pytorch/</url>
    <content><![CDATA[<h1 id="TensorBorad"><a href="#TensorBorad" class="headerlink" title="TensorBorad"></a>TensorBorad</h1><p>TensorBoard是一个可视化工具，它可以用来展示网络图、张量的指标变化、张量的分布情况等。特别是在训练网络的时候，我们可以设置不同的参数（比如：权重W、偏置B、卷积层数、全连接层数等），使用TensorBoader可以很直观的帮我们进行参数的选择。</p>
<p><strong>add_scalar()</strong></p>
<p>示例：画y=2x的图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;my_logs&quot;</span>)  <span class="comment"># 指定事件文件的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画y=2x的图像</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">	writer.add_scalar(<span class="string">&quot;y=2x图像&quot;</span>, 2i, i)  <span class="comment"># 参数：title,y,x</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p>在控制台输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tensorborad --logdir=my_logs --port=6607  <span class="comment">#port可以不指定</span></span><br></pre></td></tr></table></figure>
<p><strong>add_image()</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>c++常用库函数</title>
    <url>/cl5gc8ax30009ecu95lf5ay09/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isalpha</span>(字母);	<span class="comment">//判断是否是字母</span></span><br><span class="line"><span class="built_in">toupper</span>(字母);	<span class="comment">//转大写</span></span><br><span class="line"><span class="built_in">tolower</span>(字母);	<span class="comment">//转小写	</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>c++：文件读写、字符串</title>
    <url>/cl5gc8ax3000aecu9g16z3ci2/</url>
    <content><![CDATA[<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><h3 id="使用重定向"><a href="#使用重定向" class="headerlink" title="使用重定向"></a>使用重定向</h3><p>用freopen可以直接变成由文件输入输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);  <span class="comment">//如果不存在，将创建</span></span><br><span class="line">    </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ooo\n&quot;</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;123&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//以上两种方式都可以将数据直接写入out.txt文件</span></span><br><span class="line">    <span class="comment">//每次运行，out.txt会被重写</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重定向方式写起来简单自然，但是不能同时读写文件和标准输入输出。</p>
<span id="more"></span>
<h3 id="使用fopen"><a href="#使用fopen" class="headerlink" title="使用fopen"></a>使用fopen</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	FILE *fin,*fout;  <span class="comment">//定义两个文件指针	</span></span><br><span class="line">    fin = fopen(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);  <span class="comment">//&quot;rb&quot;表示二进制文件只读</span></span><br><span class="line">    fout = fopen(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;	</span><br><span class="line">    <span class="built_in">fscanf</span>(fin,<span class="string">&quot;%d&quot;</span>,&amp;n); <span class="comment">//指定由fin读入整数n</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fout,<span class="string">&quot;%d&quot;</span>,n); <span class="comment">//指定将n输出到fout中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见的字符串函数的用法"><a href="#常见的字符串函数的用法" class="headerlink" title="常见的字符串函数的用法"></a>常见的字符串函数的用法</h2><p>1.<code>tolower(ch)</code><br>把字符转换成小写字母，非字母字符不做处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">5</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> lower_ch[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">		lower_ch[i]=<span class="built_in">tolower</span>(ch[i]);</span><br><span class="line">		cout&lt;&lt;lower_ch[i];</span><br><span class="line">	&#125; <span class="comment">//输出：abcd</span></span><br></pre></td></tr></table></figure>
<p>2.<code>strtok(str,&quot;,&quot;)</code><br>以逗号为分隔符，将str切分成一个个子串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">16</span>] = <span class="string">&quot;abc,d&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *p; </span><br><span class="line">    p = strtok(ch, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p); </span><br><span class="line">    <span class="comment">//输出：abc  (换行）d</span></span><br></pre></td></tr></table></figure>
<p>3.<code>substr(开始下标，长度)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;My name is Ariel.&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1.substr(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;s2=&quot;</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s3=s1.substr(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;s3=&quot;</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出：s2=Y n</span></span><br><span class="line"><span class="comment">//      s3=ame is Ariel.</span></span><br></pre></td></tr></table></figure>
<p>4.<code>insert(开始下标，str)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;Ariel!&quot;</span>;</span><br><span class="line">s1.insert(<span class="number">2</span>,s2);<span class="comment">//输出：heAriel!llo</span></span><br></pre></td></tr></table></figure>
<p>5.<code>erase(开始下标，长度count)</code><br>从开始下标起，删除count个字符。<br>如果现有长度少于count或count为-1，则删到串尾。<br>默认情况下,开始下标为0；默认删除到串尾。</p>
<p>6.<code>int find_first_of(char c, int start = 0):</code><br>查找字符串中第1个出现的c,由位置start开始。<br>如果有匹配，则返回匹配位置；否则，返回-1.<br>默认情况下，start为0。 </p>
<p>7.<code>int find_last_of(char c):</code><br>找字符串中最后一个出现的c。<br>有匹配，则返回匹配位置；否则返回-1.</p>
<p>​    </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Js学习笔记</title>
    <url>/jsLearning/</url>
    <content><![CDATA[<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>在 JavaScript 中，用分号来结束语句是可选的。</p>
<h3 id="对代码行进行拆行"><a href="#对代码行进行拆行" class="headerlink" title="对代码行进行拆行"></a>对代码行进行拆行</h3><p>可以在<strong>文本字符串</strong>中使用<u>反斜杠</u>对代码行进行换行。下面的例子会正确地显示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;你好 \</span></span><br><span class="line"><span class="string">世界!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>不过，不能像这样拆行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write \ </span><br><span class="line">(<span class="string">&quot;你好世界!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>采用 // 和 /<em> </em>/ 两种。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。</p>
<p>当您声明新变量时，可以使用 “new” 来声明其类型（首字母大写）：</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> carname = <span class="keyword">new</span> <span class="built_in">String</span>;  <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Number</span>;        <span class="comment">//数字  </span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Boolean</span>;       <span class="comment">//布尔</span></span><br><span class="line"><span class="keyword">var</span> cars = <span class="keyword">new</span> <span class="built_in">Array</span>;      <span class="comment">//数组</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>;   <span class="comment">//对象</span></span><br></pre></td></tr></table></figure>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y,z=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>x, y 为 <strong>undefined</strong>， z 为 1。</p>
<h4 id="重新声明"><a href="#重新声明" class="headerlink" title="重新声明"></a>重新声明</h4><p>如果重新声明 JavaScript 变量，该变量的值不会丢失：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> carname=<span class="string">&quot;Volvo&quot;</span>; </span><br><span class="line"><span class="keyword">var</span> carname;</span><br></pre></td></tr></table></figure>
<p>两条语句执行后，变量 carname 的值依然是 “Volvo”。</p>
<h4 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h4><p>局部变量（函数内的变量，只能在函数内部访问它）会在函数运行以后被删除。</p>
<p>全局变量（函数外的变量，网页上的所有脚本和函数都能访问它）会在页面关闭后被删除。</p>
<h4 id="向未声明的-JavaScript-变量分配值"><a href="#向未声明的-JavaScript-变量分配值" class="headerlink" title="向未声明的 JavaScript 变量分配值"></a>向未声明的 JavaScript 变量分配值</h4><p>如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。</p>
<p>这条语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">carname=<span class="string">&quot;Volvo&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>将声明 window 的一个属性 carname。</p>
<p>非严格模式下给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 = <span class="number">1</span>; <span class="comment">// 不可配置全局属性</span></span><br><span class="line">var2 = <span class="number">2</span>; <span class="comment">// 没有使用 var 声明，可配置全局属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.var1); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.var1); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> var1; <span class="comment">// false 无法删除</span></span><br><span class="line"><span class="built_in">console</span>.log(var1); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> var2; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> var2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(var2); <span class="comment">// 已经删除 报错变量未定义</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>创建名为 cars 的数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cars=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">cars[<span class="number">0</span>]=<span class="string">&quot;Saab&quot;</span>;</span><br><span class="line">cars[<span class="number">1</span>]=<span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">cars[<span class="number">2</span>]=<span class="string">&quot;BMW&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>或者 (condensed array，压缩数组):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cars=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>或者 (literal array，文本数组):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cars=[<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象由花括号分隔。对象的属性以 name : value 的形式来定义。属性由逗号分隔：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">	<span class="attr">firstname</span> : <span class="string">&quot;John&quot;</span>,      <span class="comment">//在对象中写属性</span></span><br><span class="line">	<span class="attr">lastname</span> : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">	<span class="attr">id</span> : <span class="number">5566</span>,</span><br><span class="line">	<span class="attr">fullName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)    //在对象中写方法</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象属性有两种寻址方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name = person.lastname;</span><br><span class="line">name = person[<span class="string">&quot;lastname&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>调用对象的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name = person.fullName();   </span><br><span class="line"><span class="comment">//执行函数，返回：John Doe</span></span><br><span class="line"></span><br><span class="line">name = person.fullName;     </span><br><span class="line"><span class="comment">//返回：function() &#123; return this.firstName + &quot; &quot; + this.lastName; &#125;</span></span><br><span class="line"><span class="comment">//调用方法时，不加括号，返回的是函数代码（相当于把方法看成属性了）</span></span><br></pre></td></tr></table></figure>
<h3 id="undefined-、null、typeof"><a href="#undefined-、null、typeof" class="headerlink" title="undefined 、null、typeof"></a>undefined 、null、typeof</h3><p>undefined ：</p>
<p>​    表示变量不含有值。</p>
<p>​    是所有没有赋值变量的默认值，自动赋值。</p>
<p>null：</p>
<p>​    可以将变量的值设置为 null 来清空变量。</p>
<p>​    主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。</p>
<p>可以使用 typeof 操作符来检测变量的数据类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//null 和 undefined 的值相等，但类型不等：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>             <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>                  <span class="comment">// object</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>           <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>            <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h4><p>变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处可调用 carName 变量   </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;     </span><br><span class="line">    carName = <span class="string">&quot;Volvo&quot;</span>;     </span><br><span class="line">    <span class="comment">// 此处可调用 carName 变量 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例中， carName 在函数内，但是为全局变量。</p>
<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>函数存储在变量中，不需要函数名称，通常通过变量名来调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a * b&#125;;</span><br><span class="line"><span class="keyword">var</span> z = x(<span class="number">4</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="自调用函数（还不太理解）"><a href="#自调用函数（还不太理解）" class="headerlink" title="自调用函数（还不太理解）"></a>自调用函数（还不太理解）</h4><p>函数表达式可以 “自调用”。</p>
<p>自调用表达式会自动调用。</p>
<p>如果表达式后面紧跟 () ，则会自动调用。</p>
<p>不能自调用声明的函数。</p>
<p>通过添加括号，来说明它是一个函数表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">&quot;Hello!!&quot;</span>;      <span class="comment">// 我将调用自己</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>以上函数实际上是一个 <strong>匿名自我调用的函数</strong> (没有函数名)。</p>
<h4 id="JavaScript-闭包"><a href="#JavaScript-闭包" class="headerlink" title="JavaScript 闭包"></a>JavaScript 闭包</h4><p><strong>实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     </span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;     </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125; </span><br><span class="line">&#125;)();   </span><br><span class="line">add(); </span><br><span class="line">add(); </span><br><span class="line">add();   <span class="comment">// 计数器为 3</span></span><br></pre></td></tr></table></figure>
<p><strong>实例解析</strong></p>
<p>变量 add 指定了函数自我调用的返回字值。</p>
<p>自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。</p>
<p>add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。</p>
<p>这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。</p>
<p>计数器受匿名函数的作用域保护，只能通过 add 方法修改。函数是对象</p>
<p>在 JavaScript 中使用 typeof 操作符判断函数类型将返回 “function” </p>
<p>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。直观的说就是形成一个不销毁的栈环境。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6 新增了箭头函数。箭头函数的语法比普通函数更简洁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, …, 参数N) =&gt; &#123; 函数声明 &#125;</span><br><span class="line"></span><br><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, …, 参数N) =&gt; 表达式(单一)</span><br><span class="line"><span class="comment">// 相当于：(参数1, 参数2, …, 参数N) =&gt;&#123; return 表达式; &#125;</span></span><br></pre></td></tr></table></figure>
<p>当只有一个参数时，圆括号是可选的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(单一参数) =&gt; &#123;函数声明&#125;</span><br><span class="line">单一参数 =&gt; &#123;函数声明&#125;</span><br></pre></td></tr></table></figure>
<p>没有参数的函数应该写成一对圆括号:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">() =&gt; &#123;函数声明&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 </span></span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;      </span><br><span class="line">    <span class="keyword">return</span> x * y; </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// ES6 </span></span><br><span class="line"><span class="keyword">const</span> x = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x * y;</span><br></pre></td></tr></table></figure>
<h4 id="参数规则"><a href="#参数规则" class="headerlink" title="参数规则"></a>参数规则</h4><p>显式参数（形参）、隐式参数（实参）</p>
<p>JavaScript 函数定义显式参数时没有指定数据类型。</p>
<p>JavaScript 函数对隐式参数没有进行类型检测。</p>
<p>JavaScript 函数对隐式参数的个数没有进行检测。</p>
<h3 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h3><p>let 声明的变量只在其声明的块或子块中可用，这一点，与 var 相似。二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。</p>
<p>let 和 var 的区别代码实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相同的作用域或块级作用域中，不能使用 <strong>let</strong> 关键字来重置 <strong>var</strong> 关键字声明的变量:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>使用 const 声明的是常量，其值一旦被设定便不可被更改。</p>
<h3 id="常见的HTML事件"><a href="#常见的HTML事件" class="headerlink" title="常见的HTML事件"></a>常见的HTML事件</h3><p>下面是一些常见的HTML事件的列表:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">事件</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onchange</td>
<td style="text-align:left">HTML 元素改变</td>
</tr>
<tr>
<td style="text-align:left">onclick</td>
<td style="text-align:left">用户点击 HTML 元素</td>
</tr>
<tr>
<td style="text-align:left">onmouseover</td>
<td style="text-align:left">用户在一个HTML元素上移动鼠标</td>
</tr>
<tr>
<td style="text-align:left">onmouseout</td>
<td style="text-align:left">用户从一个HTML元素上移开鼠标</td>
</tr>
<tr>
<td style="text-align:left">onkeydown</td>
<td style="text-align:left">用户按下键盘按键</td>
</tr>
<tr>
<td style="text-align:left">onload</td>
<td style="text-align:left">浏览器已完成页面的加载</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="字符串可以是对象"><a href="#字符串可以是对象" class="headerlink" title="字符串可以是对象"></a>字符串可以是对象</h4><p>通常， JavaScript 字符串是原始值，可以使用字符创建： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;John&quot;</span></span><br></pre></td></tr></table></figure>
<p>但我们也可以使用 new 关键字将字符串定义为一个对象： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;John&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x <span class="comment">// 返回 String</span></span><br><span class="line"><span class="keyword">typeof</span> y <span class="comment">// 返回 Object</span></span><br></pre></td></tr></table></figure>
<p>建议：不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;John&quot;</span>;              </span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">(x === y) </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	结果为 false，因为 x 是字符串，y 是对象</span></span><br><span class="line"><span class="comment">	=== 为绝对相等，即数据类型与值都必须相等。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>关于更多字符串对象，请访问<a href="https://www.runoob.com/jsref/jsref-obj-string.html">菜鸟String对象</a></p>
<h3 id="For-In-循环"><a href="#For-In-循环" class="headerlink" title="For/In 循环"></a>For/In 循环</h3><p>for/in 语句循环遍历对象的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">fname</span>:<span class="string">&quot;John&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;Doe&quot;</span>,<span class="attr">age</span>:<span class="number">25</span>&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> person) &#123;      <span class="comment">// x 为属性名   </span></span><br><span class="line">    txt=txt + person[x]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//txt最终为：JohnDoe25</span></span><br></pre></td></tr></table></figure>
<h3 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h3><p>在 JavaScript 中有 5 种不同的数据类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
</ul>
<p>3 种对象类型：</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 个不包含任何值的数据类型：</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<p><strong>请注意：</strong></p>
<ul>
<li>NaN 的数据类型是 number</li>
<li>数组(Array)的数据类型是 object</li>
<li>日期(Date)的数据类型为 object</li>
<li>null 的数据类型是 object</li>
<li>未定义变量的数据类型为 undefined</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>(x)         <span class="comment">// 将变量 x 转换为字符串并返回</span></span><br><span class="line">x.toString()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;3.14&quot;</span>)    <span class="comment">// 返回 3.14</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot; &quot;</span>)       <span class="comment">// 返回 0 </span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;&quot;</span>)        <span class="comment">// 返回 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;99 88&quot;</span>)   <span class="comment">// 返回 NaN</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span>    <span class="comment">// 返回 5         null 转换为 0</span></span><br><span class="line"><span class="string">&quot;5&quot;</span> + <span class="literal">null</span>  <span class="comment">// 返回&quot;5null&quot;   null 转换为 &quot;null&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span> + <span class="number">1</span>     <span class="comment">// 返回 &quot;51&quot;      1 转换为 &quot;1&quot;  </span></span><br><span class="line"><span class="string">&quot;5&quot;</span> - <span class="number">1</span>     <span class="comment">// 返回 4         &quot;5&quot; 转换为 5</span></span><br></pre></td></tr></table></figure>
<h3 id="提升（hoisting）"><a href="#提升（hoisting）" class="headerlink" title="提升（hoisting）"></a>提升（hoisting）</h3><p>提升（Hoisting）是 JavaScript 默认<u>将当前作用域提升到前面去</u>的行为。提升（Hoisting）应用在变量的声明与函数的声明。</p>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JavaScript 中，函数及变量的声明总是会被解释器悄悄地被”提升”到函数的最顶部。也就是说，哪怕变量在使用后才声明，也没事（有声明就好~）。</p>
<p>但</p>
<p>声明的时候顺便初始化了（如<code>var y = 7;</code>），此时不会被“提升”。</p>
<h4 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h4><p>函数可以在声明之前调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myFunction(<span class="number">5</span>);  <span class="comment">//先调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">y</span>) </span>&#123;  <span class="comment">//再声明</span></span><br><span class="line">    <span class="keyword">return</span> y * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用表达式定义函数时无法提升。</p>
<h3 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a>“use strict”</h3><p>JavaScript 严格模式（strict mode）即在严格的条件下运行。</p>
<p><strong>实例1</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">myFunction();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    y = <span class="number">3.14</span>;   <span class="comment">// 报错 (y 未定义)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实例2</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3.14</span>;       <span class="comment">// 不报错 </span></span><br><span class="line">myFunction();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">   &quot;use strict&quot;</span>;</span><br><span class="line">    y = <span class="number">3.14</span>;   <span class="comment">// 报错 (y 未定义)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么使用严格模式:</p>
<ul>
<li><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</p>
</li>
<li><p>消除代码运行的一些不安全之处，保证代码运行的安全；</p>
</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ul>
<p>“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</p>
<p>另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。</p>
<p>更多限制，<a href="https://www.runoob.com/js/js-strict.html">点击此处</a></p>
<h3 id="浮点型数据"><a href="#浮点型数据" class="headerlink" title="浮点型数据"></a>浮点型数据</h3><p>JavaScript 中的所有数据都是以 64 位<strong>浮点型数据(float)</strong> 来存储。</p>
<p>所有的编程语言，包括 JavaScript，对浮点型数据的精确度都很难确定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">var</span> z = x + y            <span class="comment">// z 的结果为 0.3</span></span><br><span class="line"><span class="keyword">if</span> (z == <span class="number">0.3</span>)            <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>
<h3 id="JavaScript-表单"><a href="#JavaScript-表单" class="headerlink" title="JavaScript 表单"></a>JavaScript 表单</h3><p><a href="https://www.runoob.com/js/js-validation.html">JavaScript 表单</a></p>
]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>stack应用-ccf201903-2二十四点</title>
    <url>/cl5gc8ax5000eecu9hdyc99sg/</url>
    <content><![CDATA[<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>二十四点：使用 3 个加减乘除运算使得 4张纸牌上数字的运算结果为 24。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义每一个游戏由 4 个从 1-9 的数字和 3个四则运算符组成，保证四则运算符将数字两两隔开，不存在括号和其他字符，运算顺序按照四则运算顺序进行。</p>
<p>其中加法用符号 + 表示，减法用符号 -表示，乘法用小写字母 x 表示，除法用符号 / 表示。在游戏里除法为<u>整除</u>，例如 2 / 3 = 0，3 / 2 = 1, 4 / 2 = 2。<br>老师给了你 n 个游戏的解，请你编写程序<u>验证</u>每个游戏的结果是否为 24 。</p>
<span id="more"></span>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>从标准输入读入数据。</p>
<p>第一行输入一个整数 n，从第 2 行开始到第 n + 1 行中，每一行包含一个长度为 7的字符串，为上述的 24 点游戏，保证数据格式合法。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出到标准输出。 包含 n 行，对于每一个游戏，如果其结果为 24 则输出字符串 Yes，否则输出字符串 No。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">10</span></span><br><span class="line"><span class="attribute">9</span>+<span class="number">3</span>+<span class="number">4</span>x<span class="number">3</span></span><br><span class="line"><span class="attribute">5</span>+<span class="number">4</span>x<span class="number">5</span>x<span class="number">5</span></span><br><span class="line"><span class="attribute">7</span>-<span class="number">9</span>-<span class="number">9</span>+<span class="number">8</span></span><br><span class="line"><span class="attribute">5x6</span>/<span class="number">5</span>x<span class="number">4</span></span><br><span class="line"><span class="attribute">3</span>+<span class="number">5</span>+<span class="number">7</span>+<span class="number">9</span></span><br><span class="line"><span class="attribute">1x1</span>+<span class="number">9</span>-<span class="number">9</span></span><br><span class="line"><span class="attribute">1x9</span>-<span class="number">5</span>/<span class="number">9</span></span><br><span class="line"><span class="attribute">8</span>/<span class="number">5</span>+<span class="number">6</span>x<span class="number">9</span></span><br><span class="line"><span class="attribute">6x7</span>-<span class="number">3</span>x<span class="number">6</span></span><br><span class="line"><span class="attribute">6x4</span>+<span class="number">4</span>/<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Yes</span></span><br><span class="line"><span class="keyword">No</span></span><br><span class="line"><span class="keyword">No</span></span><br><span class="line"><span class="keyword">Yes</span></span><br><span class="line"><span class="keyword">Yes</span></span><br><span class="line"><span class="keyword">No</span></span><br><span class="line"><span class="keyword">No</span></span><br><span class="line"><span class="keyword">No</span></span><br><span class="line"><span class="keyword">Yes</span></span><br><span class="line"><span class="keyword">Yes</span></span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用stack。</p>
<p>先读入第一个数字，入栈。</p>
<p>然后是3次循环，每次循环读一个符号和一个数字。</p>
<p>在一次循环中，读的符号若为 x 或 / ，则弹出栈顶数字，将其与下一位数字作相应运算后再入栈；读的符号若为 + 或 - ，则下一位数字直接入栈，注意：若符号为 - ，入栈时入的是相反数（便于最后一次性相加）。</p>
<p>循环结束后，将栈内剩余的数字依次弹出相加。若为24，则Yes。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">		stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">		<span class="keyword">int</span>  a,b;</span><br><span class="line">		<span class="comment">//读第一个数字，直接push </span></span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		s.<span class="built_in">push</span>(a);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			<span class="comment">//读一个符号 </span></span><br><span class="line">			<span class="keyword">char</span> c;</span><br><span class="line">			cin&gt;&gt;c;</span><br><span class="line">			<span class="comment">//读一个数字 </span></span><br><span class="line">			cin&gt;&gt;a;</span><br><span class="line">			<span class="keyword">int</span> sum;  <span class="comment">//sum存储乘除运算的中间结果</span></span><br><span class="line">			<span class="keyword">if</span>(c==<span class="string">&#x27;x&#x27;</span>)&#123;			</span><br><span class="line">				sum=a*s.<span class="built_in">top</span>();</span><br><span class="line">				s.<span class="built_in">pop</span>();</span><br><span class="line">				s.<span class="built_in">push</span>(sum);			</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;/&#x27;</span>) &#123;			</span><br><span class="line">				sum=s.<span class="built_in">top</span>()/a;</span><br><span class="line">				s.<span class="built_in">pop</span>();</span><br><span class="line">				s.<span class="built_in">push</span>(sum);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>)&#123;			</span><br><span class="line">				s.<span class="built_in">push</span>(a);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				s.<span class="built_in">push</span>(a*(<span class="number">-1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> count=<span class="number">0</span>; </span><br><span class="line">		<span class="keyword">while</span> (!s.<span class="built_in">empty</span>())&#123;   </span><br><span class="line">			count+=s.<span class="built_in">top</span>();  <span class="comment">//依次弹出相加</span></span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;count&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">24</span>)&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>vector应用-ccf1712-2围圈报数</title>
    <url>/cl5gc8ax6000iecu97y4p7moc/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>​        1到<em>n</em>号小朋友顺时针坐一圈，围圈报数。<br>​        若一个小朋友报的数为<strong><em>k</em>的倍数</strong>或其<strong>末位数（即数的个位）为<em>k</em></strong>，则该小朋友被淘汰。</p>
<p>​        当只剩一个小朋友时，该小朋友获胜。</p>
<p>　　例如，当n=5, k=2时：<br>　　1号小朋友报数1；<br>　　2号小朋友报数2淘汰；<br>　　3号小朋友报数3；<br>　　4号小朋友报数4淘汰；<br>　　5号小朋友报数5；<br>　　1号小朋友报数6淘汰；<br>　　3号小朋友报数7；<br>　　5号小朋友报数8淘汰；<br>　　3号小朋友获胜。</p>
<p>　　给定<em>n</em>和<em>k</em>，请问最后获胜的小朋友编号为多少？</p>
<span id="more"></span>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入一行，包括两个整数<em>n</em>和<em>k</em>，意义如题目所述。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一行，包含一个整数，表示获胜的小朋友编号。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>5 2</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>3</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>7 3</p>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>4</p>
<h2 id="数据规模和约定"><a href="#数据规模和约定" class="headerlink" title="数据规模和约定"></a>数据规模和约定</h2><p>　　对于所有评测用例，1 ≤ <em>n</em> ≤ 1000，1 ≤ <em>k</em> ≤ 9。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>应用vector和迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<p>开始时，迭代器指向<code>v.begin()</code>，当迭代到<code>v.end()</code>时，重新指向<code>v.begin()</code>，从而做到循环。</p>
<p>当<code>v.size()==1</code>时退出循环。</p>
<p>循环时，若报数报到淘汰值，直接将该元素移出vector：<code>v.erase(it);</code> 。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;  <span class="comment">//0游戏中，1出局 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	 </span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="comment">//各号小朋友就位 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//游戏开始 </span></span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//报的数</span></span><br><span class="line">	<span class="keyword">for</span>(it=v.<span class="built_in">begin</span>();v.<span class="built_in">size</span>()!=<span class="number">1</span>;)&#123;  <span class="comment">//vector中晋仅剩一个元素时游戏结束 </span></span><br><span class="line">		<span class="comment">//迭代器报到末尾，则从头开始报 </span></span><br><span class="line">		<span class="keyword">if</span>(it==v.<span class="built_in">end</span>()) </span><br><span class="line">			it=v.<span class="built_in">begin</span>();</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">if</span>(count%<span class="number">10</span>==k || count%k==<span class="number">0</span>)&#123;  <span class="comment">//尾号为k 或 k的倍数 </span></span><br><span class="line">			<span class="comment">//cout&lt;&lt;*it&lt;&lt;&quot;被淘汰&quot;&lt;&lt;endl;</span></span><br><span class="line">			v.<span class="built_in">erase</span>(it);  </span><br><span class="line">			<span class="keyword">continue</span>;  <span class="comment">//删除元素后,后面元素自动往前移，所以迭代器不要增加了！ </span></span><br><span class="line">		&#125;</span><br><span class="line">		it++;		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;v[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>⭐和🌙</title>
    <url>/520zcy/</url>
    <content><![CDATA[<h1 id="致喵喵酱"><a href="#致喵喵酱" class="headerlink" title="致喵喵酱"></a>致喵喵酱</h1><span id="more"></span>
<h1 id="ฅ՞•ﻌ•՞ฅ̊"><a href="#ฅ՞•ﻌ•՞ฅ̊" class="headerlink" title="ฅ՞•ﻌ•՞ฅ̊"></a>ฅ՞•ﻌ•՞ฅ̊</h1><div style="width: 90%;margin: 0 auto">
    <canvas id="chart228" style="height: 300px"></canvas>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script>
<script type="text/javascript">
    var ctx = document.getElementById('chart228').getContext('2d');
    var options =     {
    type: 'line',
    data: {
    labels: [ '12.23', '1.18', '2.16', '3.16', '4.13', '5.10', '6.10', '7.8', '8.3', '8.29', '9.25','10.23'],
    datasets: [{
        label: '天数',
        backgroundColor: 'rgba(255, 99, 132, 0.2)',
        borderColor: 'rgb(255, 99, 132)',
        data:[26, 29, 28, 28, 27, 30, 28, 28, 26, 26, 27,28 ],
        }]
    },
    options: {
        responsive: true,
        title: {
        display: true,
        text: '周期可视化'     
        },
        "scales":{
            "yAxes":[{
                "ticks":{
                    "beginAtZero":true
                        }
                    }]
               }
    }
};
    new Chart(ctx, options);
</script>
<center><b>推测下次时间为：2021年11月19日~21日</b></center>



<p><em>*说明：</em></p>
<ol>
<li>仅罗列近一年的数据。</li>
<li>预测日期由近几个月的数据推断得出。</li>
</ol>
<h1 id="三行情书一则"><a href="#三行情书一则" class="headerlink" title="三行情书一则"></a>三行情书一则</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (you.Love(me) || !you.Love(me))&#123; </span><br><span class="line">	me.love.value++; </span><br><span class="line">	me.love.value--;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//你爱，或者不爱我</span></span><br><span class="line"><span class="comment">//爱就在那里</span></span><br><span class="line"><span class="comment">//不增不减</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> you.Love(me) <span class="keyword">or</span> <span class="keyword">not</span> you.Love(me):</span><br><span class="line">	love += <span class="number">1</span></span><br><span class="line">	love -= <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">你爱，或者不爱我</span></span><br><span class="line"><span class="string">爱就在那里</span></span><br><span class="line"><span class="string">不增不减</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>彩蛋</tag>
      </tags>
  </entry>
  <entry>
    <title>【OJ】DFS</title>
    <url>/dfs/</url>
    <content><![CDATA[<h1 id="A-n-k-与-C-n-k-（排列与组合）"><a href="#A-n-k-与-C-n-k-（排列与组合）" class="headerlink" title="$A_n^k$与$C_n^k$（排列与组合）"></a>$A_n^k$与$C_n^k$（排列与组合）</h1><p>题目大意：给定两个整数 <code>n</code> 和 <code>k</code>，求$C_n^k$  。<a href="https://leetcode-cn.com/problems/combinations/">原题链接-力扣77</a></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,4]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[3,4]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[2,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,2]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,3]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[1,4]</span>,</span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>用dfs，数组<code>a[]</code>记录一个组合结果，<code>v[]</code>记录当前数字是否访问过了。</p>
<span id="more"></span>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果没有<code>start</code>参数，即<code>dfs(int n, int k, int c)</code>，并且<code>for</code>循环中的<code>i=start</code>改成<code>i=1</code>，那么就是全排列，也就是$A_n^k$。</p>
<p>为什么呢？因为相当于在每一层中做选择的时候，可选择的数字不再局限于比前一层数字大的数字了，而是可以从所有1~n个数字中选择。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">25</span>],v[<span class="number">25</span>];</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;  <span class="comment">//res保存了所有结果</span></span><br><span class="line">    <span class="comment">/*参数说明</span></span><br><span class="line"><span class="comment">    n和k仅传参用；</span></span><br><span class="line"><span class="comment">    c表示当前已拾取了几个数（当前处在第几层）</span></span><br><span class="line"><span class="comment">    start表示本次拾取从哪个数开始    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> c, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(c==k)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="comment">//a[]中所有数据转移到vector中，保存。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v); </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//横向选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n;i++)&#123;  <span class="comment">//如果把i=start改成i=1，start参数去掉，则变成全排列</span></span><br><span class="line">            <span class="keyword">if</span>(!v[i])&#123;</span><br><span class="line">                v[i]=<span class="number">1</span>;  <span class="comment">//标记</span></span><br><span class="line">                a[c]=i;  <span class="comment">//选择</span></span><br><span class="line">                <span class="comment">//层数+1，并且下一层要从该数的下一个数开始拾取。</span></span><br><span class="line">                <span class="built_in">dfs</span>(n, k, c+<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">                v[i]=<span class="number">0</span>;  <span class="comment">//取消标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(v));   </span><br><span class="line">        <span class="built_in">dfs</span>(n,k,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">原题链接-力扣17</a></p>
<p>题目大意：输入是由数字<code>2-9</code> 组成的字符串，返回对应的手机九键中，所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">输入：<span class="keyword">digits</span> = <span class="string">&quot;23&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;ad&quot;</span>,<span class="string">&quot;ae&quot;</span>,<span class="string">&quot;af&quot;</span>,<span class="string">&quot;bd&quot;</span>,<span class="string">&quot;be&quot;</span>,<span class="string">&quot;bf&quot;</span>,<span class="string">&quot;cd&quot;</span>,<span class="string">&quot;ce&quot;</span>,<span class="string">&quot;cf&quot;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>选择dfs的理由：</p>
<ul>
<li>对每一位数字，都有几个对应的字母供它选择（横向选择）。</li>
<li>逐层递进，直到所有位的数字都选出对应的字母（纵向前进）。</li>
</ul>
<p>这题没有v[]数字数组，因为每个数字都在不同的几个字母中挑选，不存在选到其他层的字母的问题。此外，记录路径的a[]数组也改用字符串s来记录路径。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//数字和字母的映射表</span></span><br><span class="line">    <span class="keyword">const</span> string letter[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    string s;</span><br><span class="line">    vector&lt;string&gt; res;  <span class="comment">//记录所有结果</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(c==len)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//横向选择</span></span><br><span class="line">        <span class="comment">//letter[num[c]]：第ｃ层对应数字所对应的字母表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;letter[num[c]].<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(letter[num[c]][i]);　　<span class="comment">//选择一个字母加入（相当于标记）</span></span><br><span class="line">            <span class="built_in">dfs</span>(c+<span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">pop_back</span>(); <span class="comment">//退出一个字母（取消标记）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果字符串为空，也返回空。</span></span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">length</span>()==<span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        len=digits.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">//保存每一位数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            num[i] = digits[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ps：<code>string</code>也可以像<code>vector</code>一样用<code>push_back(x)</code>和<code>pop_back()</code>。</p>
<h1 id="组合总和（候选无重复，选取可重复）"><a href="#组合总和（候选无重复，选取可重复）" class="headerlink" title="组合总和（候选无重复，选取可重复）"></a>组合总和（候选无重复，选取可重复）</h1><p><a href="https://leetcode-cn.com/problems/combination-sum/">原题链接-力扣17</a></p>
<p>题目大意：给你一个<strong>无重复元素</strong>的数组 <code>candidates</code> ，找出 <code>candidates</code> 中可以使数字和为 target 的所有不同组合。可以按<strong>任意顺序</strong>返回这些组合。<code>candidates</code>中的数字可以被<strong>重复选取</strong> 。</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3], [7]]</span><br><span class="line">解释：</span><br><span class="line">2 和<span class="number"> 3 </span>可以形成一组候选，2 +<span class="number"> 2 </span>+<span class="number"> 3 </span>=<span class="number"> 7 </span>。注意<span class="number"> 2 </span>可以使用多次。</span><br><span class="line">7 也是一个候选，<span class="number"> 7 </span>=<span class="number"> 7 </span>。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>每个数字可以被重复选取，也就不用<code>v[]</code>数组了；对结果的个数没有要求，只要能凑出<code>target</code>都行，所以<code>dfs</code>的参数中也不需要记录当前的层数c了，另外需要添加start参数保证结果是“组合”而非“排列”。这题其实条件很松弛，写起来更简单。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;  <span class="comment">//记录所有结果</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">//记录单条结果</span></span><br><span class="line">    <span class="comment">/*candidates：仅是传参。rest：接下来还要凑的总和。start：避免全排列。*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> rest, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="comment">//到达非法边界，退出</span></span><br><span class="line">        <span class="keyword">if</span>(rest&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//满足题意，记录结果后退出</span></span><br><span class="line">        <span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//横向选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(candidates[i]);  <span class="comment">//选择</span></span><br><span class="line">            <span class="built_in">dfs</span>(candidates, rest-candidates[i], i);  <span class="comment">//下一次当前值还能选，所以start=i</span></span><br><span class="line">            v.<span class="built_in">pop_back</span>();  <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//单刀直入，直接dfs就完事了</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="组合总和II（候选有重复，选取无重复）"><a href="#组合总和II（候选有重复，选取无重复）" class="headerlink" title="组合总和II（候选有重复，选取无重复）"></a>组合总和II（候选有重复，选取无重复）</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">原题链接-力扣40</a></p>
<p>题目大意：给你一个<strong>有重复元素</strong>的数组 <code>candidates</code> ，找出 <code>candidates</code> 中可以使数字和为 target 的所有不同组合。可以按<strong>任意顺序</strong>返回这些组合。<code>candidates</code>中的数字<strong>不可以重复选取</strong> 。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[10,1,2,7,6,1,5]</span>, target = 8,</span><br><span class="line">输出: <span class="comment">[<span class="comment">[1,1,6]</span>,<span class="comment">[1,2,5]</span>,<span class="comment">[1,7]</span>,<span class="comment">[2,6]</span>]</span></span><br><span class="line">解释: 虽然candidates数组中有两个1，但是不能输出两次<span class="comment">[1,7]</span>。</span><br></pre></td></tr></table></figure>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>先对candidates排序，使得相同的元素挨在一起，这样做的目的是为了更容易找到相同的元素，以便于将重复的情况剔除。</p>
<p>与上一题相比，增加了两处关键代码：</p>
<ul>
<li>开始<code>dfs</code>之前，先<code>sort()</code></li>
<li>横向选择时，增加if条件判断：当<code>i&gt;start</code>且<code>candidates[i] == candidates[i-1]</code>时，直接<code>continue</code>，剪掉整个枝</li>
</ul>
<p>看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;  <span class="comment">//保存所有结果</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;  <span class="comment">//保存单次结果</span></span><br><span class="line">    <span class="comment">/*candidates: 仅传参。rest: 剩余总和。start: 避免全排列。*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> rest, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rest&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(rest==<span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;candidates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//关键去重代码：</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, rest-candidates[i], i+<span class="number">1</span>);</span><br><span class="line">            vec.<span class="built_in">pop_back</span>();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//先排序</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>【OJ】刷题记录2021-12</title>
    <url>/OJ-2021-12/</url>
    <content><![CDATA[<h1 id="STL-链表：-List"><a href="#STL-链表：-List" class="headerlink" title="STL 链表： List"></a>STL 链表： List</h1><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; linklist;</span><br></pre></td></tr></table></figure>
<h3 id="在头部或尾部添加一个元素："><a href="#在头部或尾部添加一个元素：" class="headerlink" title="在头部或尾部添加一个元素："></a>在头部或尾部添加一个元素：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">linklist.<span class="built_in">push_front</span>(head);</span><br><span class="line">linklist.<span class="built_in">push_back</span>(head);</span><br></pre></td></tr></table></figure>
<h3 id="遍历链表，并在值为x的节点后面，插入值为y的节点："><a href="#遍历链表，并在值为x的节点后面，插入值为y的节点：" class="headerlink" title="遍历链表，并在值为x的节点后面，插入值为y的节点："></a>遍历链表，并在值为x的节点后面，插入值为y的节点：</h3><span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=linklist.<span class="built_in">begin</span>(); it!=linklist.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it==x)&#123;</span><br><span class="line">        linklist.<span class="built_in">insert</span>(++it, y);  <span class="comment">//在指定位置插入</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除节点："><a href="#删除节点：" class="headerlink" title="删除节点："></a>删除节点：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据迭代器删除</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator pos )</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator start, iterator end )</span></span>;</span><br><span class="line"><span class="comment">//根据值删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">( <span class="keyword">const</span> TYPE &amp;val )</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h1><p>题目大意：对录入的学生的分数进行升序或降序排列。<a href="https://www.nowcoder.com/practice/8e400fd9905747e4acc2aeed7240978b">原题链接</a></p>
<p>输入的第一行表示学生的人数n；第二行表示按升序(1)还是降序(0)来排列；接下来的n行是学生的名字和分数。<strong>如果有学生分数相同，则按照录入的顺序来输出。</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">fang 90</span><br><span class="line">yang 50</span><br><span class="line">ning 70</span><br><span class="line">输出：</span><br><span class="line">fang 90</span><br><span class="line">ning 70</span><br><span class="line">yang 50</span><br></pre></td></tr></table></figure>
<p><strong><em>关键是cmp函数要掌握！</em></strong></p>
<p>话不多说，直接看代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">int</span> id;  <span class="comment">//记录录入的先后顺序</span></span><br><span class="line">&#125;;</span><br><span class="line">Node node[<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*cmp1：分数大的排在前*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Node x, Node y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果分数相等，按照id小的排在前</span></span><br><span class="line">    <span class="keyword">if</span>(x.score == y.score) <span class="keyword">return</span> x.id &lt; y.id;</span><br><span class="line">    <span class="keyword">return</span> x.score &gt; y.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*cmp2：分数小的排在前*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Node x, Node y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果分数相等，按照id小的排在前</span></span><br><span class="line">    <span class="keyword">if</span>(x.score == y.score) <span class="keyword">return</span> x.id &lt; y.id;</span><br><span class="line">    <span class="keyword">return</span> x.score &lt; y.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//多组输入数据</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="comment">//order指明以升序或降序来排序</span></span><br><span class="line">        <span class="keyword">int</span> order;</span><br><span class="line">        cin&gt;&gt;order;</span><br><span class="line">        <span class="comment">//读入n个学生的名字和分数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;node[i].name&gt;&gt;node[i].score;</span><br><span class="line">            <span class="comment">//id用来记录每条数据的录入顺序</span></span><br><span class="line">            node[i].id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用cmp函数</span></span><br><span class="line">        <span class="keyword">if</span>(order == <span class="number">0</span>) </span><br><span class="line">            <span class="built_in">sort</span>(node, node+n, cmp1); </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">sort</span>(node, node+n, cmp2);</span><br><span class="line">        <span class="comment">//输出按分数排序后的结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;node[i].name&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;node[i].score&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="利用unordered-map计数，并按输入顺序输出"><a href="#利用unordered-map计数，并按输入顺序输出" class="headerlink" title="利用unordered_map计数，并按输入顺序输出"></a>利用unordered_map计数，并按输入顺序输出</h1><p><a href="https://www.nowcoder.com/practice/3350d379a5d44054b219de7af6708894">原题链接</a></p>
<p>题目大意：统计每个候选人的得票数。</p>
<p>输入有4行。第1行表示候选人数n；第2行表示n个候选人的名字；第3行表示投票人数m；第4行表示m个投票结果，其中有些是废票，需要单独统计。最后<strong>按照录入顺序，输出每个候选人的得票</strong>，以及废票的数量。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="selector-tag">4</span></span><br><span class="line"><span class="selector-tag">A</span> <span class="selector-tag">B</span> <span class="selector-tag">C</span> <span class="selector-tag">D</span></span><br><span class="line"><span class="selector-tag">8</span></span><br><span class="line"><span class="selector-tag">A</span> <span class="selector-tag">D</span> <span class="selector-tag">E</span> <span class="selector-tag">CF</span> <span class="selector-tag">A</span> <span class="selector-tag">GG</span> <span class="selector-tag">A</span> <span class="selector-tag">B</span></span><br><span class="line">输出：</span><br><span class="line"><span class="selector-tag">A</span> : <span class="selector-tag">3</span></span><br><span class="line"><span class="selector-tag">B</span> : <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">C</span> : <span class="selector-tag">0</span></span><br><span class="line"><span class="selector-tag">D</span> : <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">Invalid</span> : <span class="selector-tag">3</span></span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一一映射的题目，肯定用map啊：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;候选人, 得票&gt;</span><br></pre></td></tr></table></figure>
<p>不要求排序，所以用<code>unordered_map</code>，但是<strong><code>unordered_map</code>不保证遍历顺序就是插入顺序</strong>，所以额外用vector记录一下插入的顺序。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; candidates;</span><br><span class="line">        <span class="comment">//unordered_map不保证遍历顺序就是插入顺序，所以用vector来保存插入顺序</span></span><br><span class="line">        vector&lt;string&gt; vec;  </span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;s;</span><br><span class="line">            candidates[s] = <span class="number">0</span>;  <span class="comment">//初始时，各候选人得票都是0</span></span><br><span class="line">            vec.<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">int</span> invalid = <span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;s;</span><br><span class="line">            <span class="comment">//候选人存在，计数+1</span></span><br><span class="line">            <span class="keyword">if</span>(candidates.<span class="built_in">find</span>(s) != candidates.<span class="built_in">end</span>())</span><br><span class="line">                candidates[s] ++;</span><br><span class="line">            <span class="comment">//候选人不存在，无效票+1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                invalid ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印候选人及其得票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cout&lt;&lt;vec[i]&lt;&lt;<span class="string">&quot; : &quot;</span>&lt;&lt;candidates[vec[i]]&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Invalid : &quot;</span>&lt;&lt;invalid&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】A Survey on Temporal Action Localization</title>
    <url>/surveyTAL/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文介绍了时序动作定位（Temporal Action Localization）的相关技术、基准数据集和评价指标。此外，从完全监督学习和弱监督学习两个方面，总结了时序动作定位。列举了部分代表性工作并比较了他们的性能。最后，还提出了可能的研究方向。</p>
<span id="more"></span>
<h1 id="I-引言"><a href="#I-引言" class="headerlink" title="I 引言"></a>I 引言</h1><h4 id="视频理解（video-understanding）五大任务："><a href="#视频理解（video-understanding）五大任务：" class="headerlink" title="视频理解（video understanding）五大任务："></a>视频理解（video understanding）五大任务：</h4><p>a) Untrimmed Video Classification</p>
<p>​    未分割视频的分类</p>
<p>b) Trimmed Action Recognition</p>
<p>​    已分割视频的动作识别（一个视频只包含一种动作）</p>
<p>c) Temporal Action Proposals</p>
<p>​    长视频动作分割（使各segment仅含一个动作）</p>
<p><strong>d) Temporal Action Localization</strong></p>
<p>​    时序动作定位</p>
<p>e) Dense-Captioning Events in Videos</p>
<p>​    视频中多种动作的描述</p>
<h4 id="时序动作定位（Temporal-Action-Localization）的任务包括："><a href="#时序动作定位（Temporal-Action-Localization）的任务包括：" class="headerlink" title="时序动作定位（Temporal Action Localization）的任务包括："></a>时序动作定位（Temporal Action Localization）的任务包括：</h4><ol>
<li>识别（recognition）</li>
<li>定位（localization）</li>
</ol>
<h4 id="视频定位比起图片定位的难点："><a href="#视频定位比起图片定位的难点：" class="headerlink" title="视频定位比起图片定位的难点："></a>视频定位比起图片定位的难点：</h4><ol>
<li>视频包含时序信息</li>
<li>视频动作的边界不清晰</li>
<li>时序跨度大</li>
<li>存在多尺度、多目标、镜头抖动</li>
</ol>
<h4 id="该技术的应用："><a href="#该技术的应用：" class="headerlink" title="该技术的应用："></a>该技术的应用：</h4><p>视频内容概括、监控、技巧评估、公共安全。</p>
<h1 id="II-相关技术"><a href="#II-相关技术" class="headerlink" title="II 相关技术"></a>II 相关技术</h1><p>2014以前：传统方法；2014以后：深度学习</p>
<h2 id="A-传统方法"><a href="#A-传统方法" class="headerlink" title="A 传统方法"></a>A 传统方法</h2><p>特征提取：局部的、全局的。</p>
<h4 id="基于特征点跟踪的特征提取方法"><a href="#基于特征点跟踪的特征提取方法" class="headerlink" title="基于特征点跟踪的特征提取方法"></a>基于特征点跟踪的特征提取方法</h4><ol>
<li>检测特征点（feature points）</li>
<li>逐帧跟踪特征点</li>
<li>形成轨迹</li>
<li>描述轨迹及其时序</li>
</ol>
<p>典型方法：</p>
<p>DT（Dense Trajectories， 强轨迹）-&gt; iDT（improved DT）</p>
<p>如今多将DL方法与iDT结合。</p>
<h2 id="B-深度学习（DL）方法"><a href="#B-深度学习（DL）方法" class="headerlink" title="B 深度学习（DL）方法"></a>B 深度学习（DL）方法</h2><p>分为两阶段（two-stage）方法和一阶段（one-stage）方法。</p>
<p>前人方法回顾：</p>
<p>2D-CNN</p>
<p>two-stream CNNs</p>
<p>3D CNN</p>
<p>I3D(Inception 3D)</p>
<p>RNN</p>
<p>TSN</p>
<h3 id="1）-两阶段（two-stage）方法（主流）"><a href="#1）-两阶段（two-stage）方法（主流）" class="headerlink" title="1） 两阶段（two-stage）方法（主流）"></a>1） 两阶段（two-stage）方法（主流）</h3><ol>
<li>提取temporal proposals（难点）</li>
<li>将其分类以及回归操作</li>
</ol>
<p>第一步是难点，所以各种方法也都是针对第一步来提出。评估其性能的方法：AR（Average Recall）。</p>
<h4 id="a-滑窗法-SLIDING-WINDOW-S-CNN-14-2016"><a href="#a-滑窗法-SLIDING-WINDOW-S-CNN-14-2016" class="headerlink" title="a 滑窗法 SLIDING WINDOW (S-CNN [14], 2016)"></a>a 滑窗法 SLIDING WINDOW (S-CNN [14], 2016)</h4><p><img src="image-20210927182540574.png" alt="image-20210927182540574"></p>
<p>S-CNN：固定一定大小的滑动窗口来生成不同大小的视频片段，然后通过多级网络(SegmentCNN)对其进行处理。</p>
<p>SCNN包括三个使用C3D网络的子网络：</p>
<ol>
<li>proposal网络。确定当前划分的视频片段（segment）是一个动作（action）的可能性。</li>
<li>分类网络。对视频片段进行分类。</li>
<li>定位网络。其输出是分类的概率。</li>
</ol>
<p>理论上，窗口滑动的重叠度越高，效果越好，但是计算量也大。所以用非极大值抑制（non-maximized suppression, NMS）去除重叠段。</p>
<p>缺点：滑窗法不能处理不同长度的视频动作；密集的滑窗计算量太大。</p>
<h4 id="b-时序动作组合-TEMPORAL-ACTIONNESS-GROUPING-TAG-15-2017"><a href="#b-时序动作组合-TEMPORAL-ACTIONNESS-GROUPING-TAG-15-2017" class="headerlink" title="b 时序动作组合 TEMPORAL ACTIONNESS GROUPING (TAG [15], 2017)"></a>b 时序动作组合 TEMPORAL ACTIONNESS GROUPING (TAG [15], 2017)</h4><p><img src="image-20210927182821079.png" alt="image-20210927182821079"></p>
<p>滑窗法不能处理不同长度的视频动作。</p>
<p>2017年，Y. Xiong等人提出了一个框架，可以精确划分可变视频的动作边界。该框架分为2步：</p>
<ol>
<li>生成一系列时序proposals。</li>
<li>判断这些候选是否是一个动作，并预测动作的类别。</li>
</ol>
<p>为了生成一个proposal，提出了TAG网络。TAG网络分为3步：</p>
<ol>
<li>提取片段（snippets）：每个snippet包含一个视频帧和光流（ optical flow）信息；snippet是均匀获取的；用TSN的稀疏采样方法采样。</li>
<li><p>动作判断（Actionness）：给snippet打分，确定每个snippet是否含有任何动作。用到二分类网络TSN（Temporal Segment Network）。</p>
</li>
<li><p>组合（Grouping）：依据输出的snippets序列的概率，对高概率的连续snippets进行组合，同时设置多组阈值来删除低概率的snippets。</p>
</li>
</ol>
<p>优点：对边界的处理更灵活；减少了proposal数目，减少计算量；合并片段是自底向上的，更加精确；设置多个阈值组合，可以不需改变参数的训练。</p>
<p>缺点：分类错误的话，会错过一些proposal。</p>
<p>本文在THUMOS2014上IOU=0.5时候MAP=28.25。</p>
<h4 id="c-时序单元回归网络-TEMPORAL-UNIT-REGRESS-NETWORK-TURN-TAP-16-2017"><a href="#c-时序单元回归网络-TEMPORAL-UNIT-REGRESS-NETWORK-TURN-TAP-16-2017" class="headerlink" title="c 时序单元回归网络 TEMPORAL UNIT REGRESS NETWORK (TURN TAP [16], 2017)"></a>c 时序单元回归网络 TEMPORAL UNIT REGRESS NETWORK (TURN TAP [16], 2017)</h4><p>由Gao J.Y.等人在2017年提出。</p>
<p><img src="TURN-TAP.jpg" alt=""></p>
<p>该方法将视频分成固定大小的单元（unit），例如16帧为一单元。然后将每个单元放入C3D中提取水平特征。相邻单元构成一个片段（clip），并让每个单元作为锚定单元（anchor unit）构成片段金字塔，然后在单元上执行时序坐标回归。</p>
<p>网络包含两个输出：</p>
<ol>
<li>确定片段（clip）是否包含动作的置信度</li>
<li>调整时序坐标边界的偏移量</li>
</ol>
<p>该方法的贡献：</p>
<ol>
<li>一种利用坐标回归生成时序proposal片段的新方法。</li>
<li>快（800fps）。</li>
<li>提出了一种新的评价指标AR-F。</li>
</ol>
<h4 id="d-边界敏感网络-BOUNDARY-SENSITIVE-NETWORK-BSN-21-2018"><a href="#d-边界敏感网络-BOUNDARY-SENSITIVE-NETWORK-BSN-21-2018" class="headerlink" title="d 边界敏感网络 BOUNDARY SENSITIVE NETWORK (BSN [21], 2018)"></a>d 边界敏感网络 BOUNDARY SENSITIVE NETWORK (BSN [21], 2018)</h4><p>原作者解读：<a href="https://zhuanlan.zhihu.com/p/39327364">[ECCV 2018] 用于时序动作提名生成的边界敏感网络 - 知乎 (zhihu.com)</a></p>
<p><img src="image-20210927185640495.png" alt="image-20210927185640495"></p>
<p>高质量的时序动作候选（proposals）应该具有以下几个特点：</p>
<p>a)灵活的时序长度；</p>
<p>b)精确的时序边界；</p>
<p>c)可靠的置信度分数。</p>
<p>事实上，想同时在这3个方面做的好是很难的。为此，T. Lin（林天威）等人在2018年提出了BSN。</p>
<p>BSN步骤：</p>
<ol>
<li>首先确定时序动作片段的边界，并将其此片段直接作为proposal。</li>
<li>对每个候选proposal，基于动作序列的置信度，提取32维的proposal级别的特征。</li>
<li>最后，根据所提取的这些特征，评估这些proposal的置信度。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><strong>框架</strong>：提出了一种全新的且非常有效的时序提名生成框架，能够产生满足(1)时长灵活(2)边界准确(3)评分可靠的时序动作提名；</li>
<li><strong>灵活性</strong>：BSN方法的模块非常简单且灵活，能够灵活地应用于不同的垂类场景。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>效率不够高</strong>：提名特征提取以及置信度评估的过程是对每个时序提名逐个进行的，虽然可以在一定程度上做并行加速，但总体上还是效率比较差；</li>
<li><strong>语义信息丰富性不足</strong>：为了保证提名特征提取过程的效率，BSN中所设计的32维提名特征是比较简单的，但也限制了置信度评估模块从特征中获得更加丰富的语义信息；</li>
<li><strong>多阶段</strong>：BSN方法是一个多阶段的方法，没有将几部分网络联合优化。</li>
</ul>
<h4 id="e-边界匹配网络-BOUNDARY-MATCHING-NETWORK-BMN-72-2019"><a href="#e-边界匹配网络-BOUNDARY-MATCHING-NETWORK-BMN-72-2019" class="headerlink" title="e 边界匹配网络 BOUNDARY-MATCHING NETWORK (BMN [72], 2019)"></a>e 边界匹配网络 BOUNDARY-MATCHING NETWORK (BMN [72], 2019)</h4><p>原作者解读：<a href="https://zhuanlan.zhihu.com/p/75444151">[ICCV 2019][时序动作提名] 边界匹配网络详解 - 知乎 (zhihu.com)</a></p>
<p>为了解决BSN的不足所提出。</p>
<p>BMN网络能够同时生成与BSN中类似的一维边界概率序列，以及二维的BM置信度图来密集的评估所有可能存在的时序提名的置信度分数。</p>
<h3 id="2）-一阶段（one-stage）方法"><a href="#2）-一阶段（one-stage）方法" class="headerlink" title="2） 一阶段（one-stage）方法"></a>2） 一阶段（one-stage）方法</h3><p>这种方法同时处理proposal和分类。</p>
<h4 id="SSAD（single-shot-temporal-action-detection，单镜头时序动作检测）"><a href="#SSAD（single-shot-temporal-action-detection，单镜头时序动作检测）" class="headerlink" title="SSAD（single shot temporal action detection，单镜头时序动作检测）"></a>SSAD（single shot temporal action detection，单镜头时序动作检测）</h4><p>结合了在目标检测中的YOLO和SSD模型的特性。</p>
<p>其流程如下：利用预训练模型，得到特征序列作为SSAD模型的输入。经过处理后，模型输出检测结果。</p>
<p>用C3D提取特征。</p>
<h4 id="SS-TAD（end-to-end-single-stream-temporal-action-detection，端到端，单流时序动作检测）"><a href="#SS-TAD（end-to-end-single-stream-temporal-action-detection，端到端，单流时序动作检测）" class="headerlink" title="SS-TAD（end-to-end, single-stream temporal action detection，端到端，单流时序动作检测）"></a>SS-TAD（end-to-end, single-stream temporal action detection，端到端，单流时序动作检测）</h4><p>利用时序动作定位的语义子任务作为调整后的语义约束（semantic constraints）来提高训练和测试性能。</p>
<p>效率上比SSAD更好。</p>
<p>用C3D提取特征。</p>
<h4 id="GTAN（Gaussian-Temporal-Awareness-Networks，高斯时序感知网络）"><a href="#GTAN（Gaussian-Temporal-Awareness-Networks，高斯时序感知网络）" class="headerlink" title="GTAN（Gaussian Temporal Awareness Networks，高斯时序感知网络）"></a>GTAN（Gaussian Temporal Awareness Networks，高斯时序感知网络）</h4><p>引入高斯核函数（Gaussian kernels），动态优化每个动作proposal的时序范围。</p>
<h1 id="III-基准数据集"><a href="#III-基准数据集" class="headerlink" title="III 基准数据集"></a>III 基准数据集</h1><p>最火的是THUMOS14和ActivityNet。</p>
<p>A. THUMOS’14</p>
<p>B. ActivityNet</p>
<p>C. MEXaction2 </p>
<p>D. MUTITHUMOS </p>
<p>E. CHARADES</p>
<p>F. AVA</p>
<h1 id="IV-评价指标"><a href="#IV-评价指标" class="headerlink" title="IV 评价指标"></a>IV 评价指标</h1><p><strong>平均召回Average Recall (AR)</strong></p>
<p><strong>平均精度Meam Average Precision (mAP)</strong></p>
<p>通常比较的是t-IoU=0.5时的mAP。</p>
<h1 id="V-发展近况"><a href="#V-发展近况" class="headerlink" title="V 发展近况"></a>V 发展近况</h1><h2 id="完全监督的时序动作定位（F-TAL，FULL-Y-SUPETVISED-TEMPORAL-ACTION-LOCALIZATION）"><a href="#完全监督的时序动作定位（F-TAL，FULL-Y-SUPETVISED-TEMPORAL-ACTION-LOCALIZATION）" class="headerlink" title="完全监督的时序动作定位（F-TAL，FULL Y-SUPETVISED TEMPORAL ACTION LOCALIZATION）"></a>完全监督的时序动作定位（F-TAL，FULL Y-SUPETVISED TEMPORAL ACTION LOCALIZATION）</h2><p>完全监督：每个训练集都有相应的标签。</p>
<h2 id="弱监督的时序动作定位（W-TAL，WEAKLY-SUPETVISED-TEMPORAL-ACTION-LOCALIZATION）"><a href="#弱监督的时序动作定位（W-TAL，WEAKLY-SUPETVISED-TEMPORAL-ACTION-LOCALIZATION）" class="headerlink" title="弱监督的时序动作定位（W-TAL，WEAKLY-SUPETVISED TEMPORAL ACTION LOCALIZATION）"></a>弱监督的时序动作定位（W-TAL，WEAKLY-SUPETVISED TEMPORAL ACTION LOCALIZATION）</h2><p>弱监督：</p>
<ol>
<li>不完全监督（Incomplete supervised）：仅一部分训练集含有标签。</li>
<li>不精确监督（Inexact supervised）：训练集只有粗粒度的标签。</li>
<li>不正确监督（Inaccurate supervised）：标签可能有错误。</li>
</ol>
<p>对于弱监督的时序动作定位，只有视频级的标签（没有帧级别的），所以属于第二类。</p>
<h1 id="VI-未来方向"><a href="#VI-未来方向" class="headerlink" title="VI 未来方向"></a>VI 未来方向</h1><ol>
<li>同时提高精度和效率。这是一对矛盾。</li>
<li>从一维的时序动作检测转向二维的时空动作检测。</li>
<li>在线视频的动作检测。</li>
<li>弱监督的W-TAL会更加流行，因为这在现实中更普遍。</li>
<li>由于视频包含图像和音频，也许能借助音频来辅助时序动作定位。</li>
</ol>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>-论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】BSN：Boundary Sensitive Network for Temporal Action Proposal Generation</title>
    <url>/bsn/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇论文主要针对时序动作提名生成(temporal action proposal generation)任务提出了一种新的方法-边界敏感网络(Boundary Sensitive Network, BSN)。</p>
<p>BSN网络采用了”local to global”方法，local是指先定位可能性大的时序边界，再整合这些边界作为候选；global是指通过评估一个候选中是否包含动作的置信度来检索候选。用到的数据集是ActivityNet-1.3和THUMOS14。</p>
<span id="more"></span>
<p><strong>高质量的候选应满足：</strong></p>
<p>（1） 召回率（recall）要高（即“找得全”），同时与真实动作区域的重叠度（overlap）要大。</p>
<p>（2） 使用较少的候选就能实现高召回率和高重叠度。</p>
<p><strong>BSN产生候选要三步：</strong></p>
<p>（1）评估视频中的每个时间位置的概率，判断它是在真实动作实例的边界内部还是外部，在或不在真实动作实例的边界处，以生成<strong>起始</strong>、<strong>结束</strong>和<strong>动作</strong>概率序列作为local信息；</p>
<p>（2）直接合并分别具有高起始和结束概率的时间位置来生成候选。使用这种从底向上的方法，BSN可以产生<u>持续时间灵活</u>且<u>边界精确</u>的候选；</p>
<p>（3）使用由候选内部及其时序前后的动作得分组成的特征，BSN通过评估候选是否包含动作的置信度来检索候选。这些候选片段级的特征为更好的评估提供了全局信息。</p>
<p><strong>论文贡献：</strong></p>
<p>（1） 提出了“local to global”的BSN来生成高质量的时序动作候选。locally，定位高概率边界位置以获得精确的候选边界；globally，评估proposal-level的特征以获得可靠的候选置信度评分用于检索。</p>
<p>（2） 获得了比其他方法更好的候选质量。</p>
<p>（3） 与已有的动作分类器结合，显著提高了时序动作检测任务的性能。</p>
<p>BSN的<strong>缺点</strong>：</p>
<ul>
<li><strong>效率不够高</strong>：提名特征提取以及置信度评估的过程是对每个时序提名逐个进行的，虽然可以在一定程度上做并行加速，但总体上还是效率比较差；</li>
<li><strong>语义信息丰富性不足</strong>：为了保证提名特征提取过程的效率，BSN中所设计的32维提名特征是比较简单的，但也限制了置信度评估模块从特征中获得更加丰富的语义信息；</li>
<li><strong>多阶段</strong>：BSN方法是一个多阶段的方法，没有将几部分网络联合优化。</li>
</ul>
<h1 id="模型方法"><a href="#模型方法" class="headerlink" title="模型方法"></a>模型方法</h1><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>在产生时序动作候选时，是不考虑动作实例的具体类别的。视频的标签是每个动作实例的开始和结束时间。视频的标签在训练时使用；预测时，应使得产生的候选以高召回率和高重叠率覆盖视频标签。</p>
<h2 id="（a）视频特征编码"><a href="#（a）视频特征编码" class="headerlink" title="（a）视频特征编码"></a>（a）视频特征编码</h2><p>为了产生视频的候选，首先应该提取视频的视觉内容特征。本文采用双流网络作为视觉编码器。</p>
<p>双流网络：在动作识别、时序动作检测和候选生成等任务中，都有很好的效果。双流网络包括两个分支：<u>空间网络</u>通过单RGB帧来捕捉外观特征，<u>时间网络</u>通过堆叠光流域(stacked optical flow field)来捕捉运动信息。</p>
<p>根据视频得到多个小段（snippet），每个小段都由<u>单帧</u>（single frame）和以单帧为中心得到的<u>堆叠光流域</u>(stacked optical flow field)两部分组成。单帧送入<u>空间网络</u>，堆叠光流域送入<u>时序网络</u>，然后整合两个网络的顶端输出，作为双流特征向量，送入BSN网络作为输入。示意图如下图(a)。</p>
<p><img src="image-20211005111147012.png" alt="image-20211005111147012"></p>
<center>Fig.1 论文整体框架</center>

<h2 id="（b）边界敏感网络"><a href="#（b）边界敏感网络" class="headerlink" title="（b）边界敏感网络"></a>（b）边界敏感网络</h2><p>包括3个模块：时序评估，候选产生，候选评估。</p>
<h3 id="时序评估模块-TEM"><a href="#时序评估模块-TEM" class="headerlink" title="时序评估模块 TEM"></a>时序评估模块 TEM</h3><p>输入是基于双流网络提取的图像特征序列。采用<u>3层时序卷积层</u>来对视频序列中每个位置上动作开始的概率、动作结束的概率和动作进行的概率同时进行建模，从而生成 动作开始概率序列，动作结束概率序列和动作概率序列。</p>
<p>3层卷积层分别表示为Conv(512, 3, Relu)，Conv(512, 3, Relu)，Conv(3, 1, Sigmoid)。其中，第一项为过滤器数量，第二项为卷积核大小，第三项为激励函数，三层的步长都为1。最后一层卷积层作为分类器，产生起始，结束和动作概率。</p>
<p>此模块的输入是特征序列，输出是起始，结束和动作概率。</p>
<h3 id="候选生成模块-PGM"><a href="#候选生成模块-PGM" class="headerlink" title="候选生成模块 PGM"></a>候选生成模块 PGM</h3><p>此模块的目的是产生候选片段并建立相应的片段级特征。分两步来实现这个目的，（1）找到高边界概率的位置，并合并这些位置组成候选片段；（2）对于每个候选片段，建立BSP特征。</p>
<p><strong>生成候选片段</strong></p>
<p>满足：</p>
<p>（1）概率高于一个阈值；或</p>
<p>（2）该时间节点的概率高于前一时刻以及后一时刻的概率（即一个概率峰值）。</p>
<p>这样的节点将被作为候选时序边界节点。然后将候选开始时间节点和候选结束时间节点两两结合，保留时长符合要求的开始节点-结束节点组合作为候选时序动作提名。所谓的时长符合要求，就是时长应处在数据集中动作实例标签的最小时长和最大时长之间。</p>
<p>如下图。</p>
<p><img src="image-20211005113151719.png" alt="image-20211005113151719"></p>
<p><strong>建立BSP特征</strong></p>
<p>对于每个提名，取其本身的时序区间作为<u>中心区域</u>，表示为$r_C=[t_s,t_e]$，另外其时长记为$d=t_e-t_s$ ，再取开始节点和结束节点附近的一段区间作为<u>起始区域</u> $r_S=[t_s-d/5，t_s+d/5]$以及 <u>结束区域</u>$r_E=[t_e-d/5，t_e+d/5]$。将$r_C$内的动作序列以16点的线性插值法进行采样，对于$r_S$和$r_E$以8点的线性插值法进行采样，将这三个采样得到的向量进行连接，就得到了这个候选的BSP特征$f_{BSP}$。BSP特征包含了对应候选片段的丰富的语义信息。每个候选片段都表示为$(t_s,t_e,f_{BSP})$。</p>
<p>如下图。</p>
<p><img src="image-20211005113237307.png" alt="image-20211005113237307"></p>
<h3 id="候选评估模块-PEM"><a href="#候选评估模块-PEM" class="headerlink" title="候选评估模块 PEM"></a>候选评估模块 PEM</h3><p>此模块的目的是用BSP特征来评估每个候选片段中包含动作实例的置信度得分。作者采用了有1个隐藏层的多层感知器模型，这个隐藏层有512个单元，以Relu激励来处理BSP特征输入。而输出层以sigmoid激励来输出置信度得分$p_{conf}$，这个得分评估的是候选片段与真实动作实例之间的重叠范围。因此生成的候选片段可以表示为$(t_s,t_e,p_{conf},p_{t_s},p_{t_e})$，其中后两项分别表示$t_s$的起始概率和$t_e$的结束概率。融合这些得分，得到预测的最终得分。</p>
<p><img src="image-20211005111147012.png" alt="image-20211005111147012"></p>
<h2 id="训练BSN"><a href="#训练BSN" class="headerlink" title="训练BSN"></a>训练BSN</h2><p><strong>时序评估模块</strong></p>
<p>（1）先将视频以固定的帧间隔处理为多个小段，再提取每个小段的特征得到这个视频的小段特征序列（序列中有ls个小段）；（2）采用长度为100的滑动窗口，在特征序列上滑动，没有重叠，得到的每个窗口都有两部分信息，一个是这段窗口中的特征序列，一个是这个窗口中的标签（标签就是这个窗口中的动作实例的开始ts和结束te，我们将这个范围作为动作范围，这里的开始和结束原本是某一帧，但也将其处理为一个范围，即ts变成 [ts − d/10, ts + d/10]，te变成 [te − d/10, te + d/10]），即起始帧变为起始范围，结束帧变为结束范围）；（3）将一个窗口的特征序列作为输入，时序评估模块产生了起始概率序列，结束概率序列和动作概率序列，长度都等于滑动窗口的长度；（4）对于一个窗口中的每个位置tn，将它的范围定义为 [tn − ds/2, tn + ds/2]，ds=tn-t(n-1)，即两个小段间的时序间隔，并从这个窗口的三个概率序列中分别得到这个位置的对应概率得分；（5）此时，对于窗口中某个位置tn的范围，我们可以分别计算它跟标签的动作范围，起始范围和结束范围的IoP；（6）因此我们可以用6个信息来表示tn的信息——tn的动作概率，tn的起始概率，tn的结束概率，tn的范围与动作范围的最大匹配重叠率IoP，tn的范围与起始范围的最大匹配重叠率IoP，tn的范围与结束范围的最大匹配重叠率IoP。</p>
<p>这个模块的loss由动作loss，起始loss和结束loss三部分组成。即</p>
<p><img src="image-20211005152830434.png" alt="image-20211005152830434"></p>
<p>动作loss，起始loss和结束loss的计算公式是相同的，即</p>
<p><img src="image-20211005152843659.png" alt="image-20211005152843659"></p>
<p><strong>候选评估模块</strong></p>
<p>用时序评估模块产生的概率序列，候选生成模块可以产生候选片段（ts，te，fBSP）。（1）候选评估模块将候选的BSP特征作为输入，可以得到这个候选的置信度得分；（2）再计算这个片段跟所有标签的IoU，并记录最大的重叠得分giou；（3）将候选片段集分为两个部分，一个是giou大于0.7的正样本集，一个是giou小于0.3的负样本集；（4）为了数据平衡，作者采用了正样本集中的所有样本，再从负样本集中随机挑选样本，使得两个片段集的比例大概为1:2。</p>
<p>这个模块的目标函数是简单的回归loss，即</p>
<p><img src="image-20211005152908321.png" alt="image-20211005152908321"></p>
<p><strong>预测和后处理</strong><br>候选评估模块用$(t_s,t_e,p_{conf},p_{t_s},p_{t_e})$五种信息来表示候选片段，还需要融合这些得分来得到预测的最终得分。</p>
<p>Score fusion for retrieving：Pf = Pconf <em> Pts </em> Pte，这个Pf被用于候选检索</p>
<p>Redundant proposals suppression：在一个动作实例周围可能会得到多个不同时序重叠率的候选片段，因此需要压制冗余的候选片段，以减少候选片段，获得更高的召回率。</p>
<p>Soft-NMS是一种使用得分衰减函数来压制冗余结果的非极大值抑制算法。（1）先将所有候选片段按得分排序；（2）计算得分最高的候选片段与其他候选片段的IoU，使得重叠高的候选片段减少；（3）对剩余的候选片段递归地执行第二步，来产生重新计算的候选片段集。Soft-NMS的高斯衰减函数可以表示为：</p>
<p><img src="image-20211005153011130.png" alt="image-20211005153011130"></p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="数据集和设置"><a href="#数据集和设置" class="headerlink" title="数据集和设置"></a>数据集和设置</h2><p><strong>数据集：</strong>ActivityNet-1.3包含19994个视频，200个动作类别，以2:1:1的比例划分训练、验证、测试集。THUMOS14验证集和测试集中有时序标注的视频分别有200和213个，有20个动作类别。</p>
<p><strong>评价指标：</strong>时序候选生成任务中，常用以多个IoU阈值计算得到的平均召回率（AR）作为评价指标。本文中，在ActivityNet-1.3上使用的IoU阈值集为[0.5 : 0.05 : 0.95]，THUMOS14上是[0.5 : 0.05 : 1.0]。为了评估召回率和候选数量的关系，作者在两个数据集上都评估了平均候选数量（AN）下的AR，即AR@AN。在ActivityNet-1.3上，AR和AN曲线下的面积之比（AUC）也被作为评价指标之一，AN的变化范围是0到100。常用评价指标还有mAP。在ActivityNet-1.3上，还使用了IoU阈值{0.5, 0.75, 0.95}下的mAP和IoU阈值集[0.5 : 0.05 : 0.95]下的平均mAP；在THUMOS14上，使用了IoU阈值为{0.3, 0.4, 0.5, 0.6, 0.7}时的mAP。</p>
<p><strong>总结：</strong></p>
<p>（1）平均召回率（AR）</p>
<p>（2）AR@AN：评估召回率和候选片段数量的关系，即评估模型以高召回率来产生和检索候选的能力</p>
<p>（3）AUC：AR@AN曲线下的面积，评估模型以高召回率来产生和检索候选的能力</p>
<p>（4）mAP</p>
<p>（5）recall of multiple IoU thresholds：评估模型以高时序重叠来产生和检索候选的能力</p>
<p><strong>实现细节：</strong>对于视觉特征编码，作者使用的是双流网络，其中BN-Inception网络作为时序网络，ResNet网络作为空间网络。这个双流网络是用Caffe实现的，是在ActivityNet-1.3的训练集上预训练的。在特征提取阶段，ActivityNet-1.3上小段之间的间隔σ为16，THUMOS14上为5。</p>
<p>在ActivityNet-1.3上，因为视频长度的限制，作者将每个视频的特征序列长度用线性插值的方法变为了100，也将对应的标签的duration变为了范围0到1。BSN中，时序评估模块和候选评估模块都是用TensorFlow实现的。在两个数据集上，训练时序评估模块时，前10个epoch中batch size为16，学习率为0.001,接下来10个epoch上，学习率为0.0001；训练候选评估模块时，batch size为256，学习率与前面一样。对于Soft-NMS，在ActivityNet-1.3上阈值θ被设为0.8，THUMOS14上为0.65，而高斯函数ε在两个数据集上都设为0.75。</p>
<h2 id="时序候选生成"><a href="#时序候选生成" class="headerlink" title="时序候选生成"></a>时序候选生成</h2><p>实验一：实验主要分两方面：（1）评估模型以高召回率产生和检索候选的能力（AR@AN，AUC），结论是BSN始终优于其他方法，但当AN小的时候，优势更明显；（2）评估模型以高时序重叠来产生和检索候选的能力（recall of multiple IoU threshold），作者测试了AN为100和1000两种情况，结论是，当候选数量小的时候，无论tIoU高还是低，BSN始终最优，当候选数量大的时候，BSN在tIoU大于0.8时最优。</p>
<p>实验二：将双流网络提取视频特征的部分替换为了C3D，将Soft-NMS换成Greedy-NMS试了，证明是BSN本身的结构带来的性能提升。</p>
<p>实验三：验证BSN在没见过的动作类别上的性能：在ActivityNet-1.3中选择了两个不同语义的动作子集，“Sports, Exercise, and Recreation”作为看过的数据集，包括了87个动作类别，4455个训练视频和2198个验证视频，“Socializing, Relaxing, and Leisure”作为没看过的数据集，包括了38个动作类别，1903个训练视频和896个验证视频。为了确保实验的有效性，没有使用在ActivityNet-1.3预训练的双流网络提取视频特征，而是使用了在Sports-1M上预训练的C3D网络，实验证明在没见过的类别上，性能只有微小的下降，因此证明了BSN的一般性。</p>
<p>实验四：验证BSN中TEM模块和PEM模块的有效性。没有PEM的话，BSN效果依然比其他方法好，但有PEM可以带来进一步的提高。</p>
<p>实验五：比较了BSP特征只要Boundary region、只要Center region和两者都要的情况，结论是，虽然center region的贡献比boundary region大，但还是两者都要的情况下效果最好。</p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>-论文笔记 -BSN</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】FiarMOT</title>
    <url>/FairMOT/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>MOT（Multi-Object Tracking）：目标是估计视频中显示的感兴趣对象的轨迹。</p>
<p>先前的工作大多采用两个模型：</p>
<p><strong>检测</strong>模型首先通过每个帧中的边界框检测感兴趣的目标，然后<strong>关联</strong>模型从每个边界框对应的图像区域中提取re-ID特征，将检测链接到现有轨迹之一，或根据特征上定义的某些指标创建新轨迹。</p>
<p>缺点：存在可扩展性问题。当有大量目标时无法达到实时推理速度，因为两模型不共享特征，它们需要为视频中的每个边界框独立应用re-ID模型。</p>
<p>作者分析了先前的一次性（one-shot）跟踪器效果不好的原因：</p>
<ul>
<li>锚（anchor）。锚不适合提取re-ID特征，因为<ul>
<li>忽略了re-ID任务。先用锚检测目标，然后才基于检测结果来提取re-ID特征。所以当检测错误时，re-ID特征也就没用了（即re-ID特征的质量严重依赖于训练时proposal的质量）。导致模型往往偏向于提高检测目标的结果，这对re-ID网络的学习不<strong>公平</strong>（<strong>fair</strong>）。</li>
<li>在训练re-ID特征时存在不确定性。因为一个锚可能对应多个身份，多个锚也可能对应一个身份，特别是在拥挤人群场景中。</li>
</ul>
</li>
</ul>
<p><img src="/image-20220702155007007.png" alt="image-20220702155007007"></p>
<ul>
<li>两个任务之间的特征共享。现有方法中，大多数特征在目标检测和re-ID任务之间共享。但目标检测需要深层特征来估计目标类别和位置，但re-ID需要低级外观特征来区分同一类别的不同实例。所以共享特征会降低每个任务的性能。所以要多层特征融合。</li>
<li>特征维度。re-ID特征的维度通常高达512，远高于目标检测。维度之间的巨大差异会影响两个任务的性能。此外，作者实验表明，对于one-shot方法，低维re-ID特征能达到更高的跟踪精度和效率。</li>
</ul>
<p>作者基于CenterNet提出FairMOT，将detection和re-ID任务同等对待。<strong>两个分支是完全相同的</strong>。</p>
<p><img src="/image-20220702104721399.png" alt="image-20220702104721399"></p>
<p>FairMOT在多个数据集（如2DMOT15、MOT16、MOT17和MOT20）上大大优于以前的SOTA方法。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>作者将相关的MOT工作分为两类：1. 单一模型； 2. 将模型分为目标检测和提取关联特征。作者讨论了两类工作的优缺点，并将作者的方法与之作了比较。</p>
<p>对于先检测再跟踪的方法：</p>
<ul>
<li>好处是可以分别为每个任务开发最合适的模型；此外，可以根据检测到的边界框裁剪图像，并在估计re-ID特征之前将其调整为相同大小，有利于不同尺度目标的处理。</li>
<li>缺点是慢。因为两项子任务需要单独完成，而不共享。</li>
</ul>
<p>对于检测和跟踪在一个网络中的方法：</p>
<ul>
<li>好处是快。</li>
<li>缺点是精度不够。</li>
</ul>
<h2 id="FairMOT"><a href="#FairMOT" class="headerlink" title="FairMOT"></a>FairMOT</h2><h3 id="骨干网络"><a href="#骨干网络" class="headerlink" title="骨干网络"></a>骨干网络</h3><p>采用ResNet-34作为骨干网络，将增强的DLA加入骨干网络来融合多层特征，所有上采样模块中的卷积层都被<strong>可变形卷积</strong>所取代，因此它们可以根据目标的比例和姿势动态调整感受野。</p>
<p>结果模型命名为DLA-34。输入图片是$C\times H_{image}\times W_{image}$，输出特征图为$C\times H\times W$，其中$H=H_{image} / 4$，$W=W_{image} / 4$。</p>
<h3 id="检测分支"><a href="#检测分支" class="headerlink" title="检测分支"></a>检测分支</h3><p>检测分支建立在CenterNet之上（其他一些无锚的方法也可以）。DLA-34后加三个并行的头，分别用于估计热图、目标中心偏移和边界框大小。每个头对DLA-34的输出特征使用3×3卷积（256个通道）来实现，然后是生成最终目标的1×1卷积层。</p>
<h4 id="热图头（Heatmap-Head）"><a href="#热图头（Heatmap-Head）" class="headerlink" title="热图头（Heatmap Head）"></a>热图头（Heatmap Head）</h4><p>负责估计物体中心的位置。采用了基于热图的表示法。热图的大小是$1\times H\times W$。如果热图中的某个位置随GT目标中心下降，则预计其响应为1。响应随着热图位置和目标中心之间的距离呈指数衰减。</p>
<p>设$\left(c_{x}^{i}, c_{y}^{i}\right)$是GT box $b^i$ 的中心点，那么$\left(\widetilde{c}_{x}^{i},{\widetilde{c_{y}^{i}}}_{i}^{i}\right)=\left(\left\lfloor\frac{c_{x}^{i}}{4}\right\rfloor,\left\lfloor\frac{c_{y}^{i}}{4}\right\rfloor\right)$表示特征图上的中心点。则热图响应值的计算公式为：</p>
<script type="math/tex; mode=display">M_{x y}=\sum_{i=1}^{N} \exp { }^{-\frac{\left(x-\tilde{c}_{x}^{i}\right)^{2}+\left(y-\tilde{c}_{y}^{i}\right)^{2}}{2 \sigma_{c}^{2}}}</script><p>其中$N$是图象中目标的个数，$\sigma_c$是标准差。</p>
<p>损失函数focal loss：</p>
<script type="math/tex; mode=display">L_{\text {heat }}=-\frac{1}{N} \sum_{x y} \begin{cases}\left(1-\hat{M}_{x y}\right)^{\alpha} \log \left(\hat{M}_{x y}\right), & M_{x y}=1 \\ \left(1-M_{x y}\right)^{\beta}\left(\hat{M}_{x y}\right)^{\alpha} \log \left(1-\hat{M}_{x y}\right) & \text { otherwise }\end{cases}</script><h4 id="框偏移和大小头（Box-Offset-and-Size-Heads）"><a href="#框偏移和大小头（Box-Offset-and-Size-Heads）" class="headerlink" title="框偏移和大小头（Box Offset and Size Heads）"></a>框偏移和大小头（Box Offset and Size Heads）</h4><p>框偏移头估计每个像素相对于对象中心的连续偏移，以减轻下采样的影响。</p>
<p>框大小头估计每个位置目标框的高度和宽度。</p>
<p>记GT box为$\left(x_{1}^{i}, y_{1}^{i}, x_{2}^{i}, y_{2}^{i}\right)$ ，box size为$s^i$，则$\mathbf{s}^{i}=\left(x_{2}^{i}-x_{1}^{i}, y_{2}^{i}-y_{1}^{i}\right)$，box offset为$o^i$，则$\mathbf{o}^{i}=\left(\frac{c_{x}^{i}}{4}, \frac{c_{y}^{2}}{4}\right)-\left(\left\lfloor\frac{c_{x}^{i}}{4}\right\rfloor,\left\lfloor\frac{c_{y}^{i}}{4}\right\rfloor\right)$</p>
<p>两个头的$l_1$损失：</p>
<script type="math/tex; mode=display">L_{\mathrm{box}}=\sum_{i=1}^{N}\left\|\mathbf{o}^{i}-\hat{\mathbf{o}}^{i}\right\|_{1}+\lambda_{s}\left\|\mathbf{s}^{i}-\hat{\mathbf{s}}^{i}\right\|_{1}</script><h3 id="re-ID分支"><a href="#re-ID分支" class="headerlink" title="re-ID分支"></a>re-ID分支</h3><p>re ID分支旨在生成能够区分目标的特征。理想情况下，不同目标之间的关系（affinity）应小于相同目标之间的关系。为了实现这一目标，我们在主干特征之上应用了128个卷积核的卷积层来提取每个位置的re-ID特征。</p>
<p>作者通过分类任务来学习re-ID特征。训练集中具有相同身份的所有目标实例被视为同一类。</p>
<p>首先在热图上获取目标中心，提取re-ID特征向量，并通过全连接层和softmax操作映射到类别分布向量P。</p>
<p>re-ID损失：</p>
<p><img src="/image-20220702231116613.png" alt="image-20220702231116613" style="zoom:80%;" /></p>
<p>其中K是训练集中所有身份的数量。</p>
<p>在网络训练过程中，只使用位于目标中心的身份嵌入向量进行训练，因为我们可以在测试时从目标热图中获得目标中心。</p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>总的损失：</p>
<p><img src="/image-20220702231620380.png" alt="image-20220702231620380" style="zoom:80%;" /></p>
<p>其中$\omega_1$和$\omega_2$是学习参数，用于平衡两个任务。</p>
<p>具体来说，给定一个包含几个目标及其对应身份的图像，我们生成热图、框偏移和大小图以及目标的一个独热（one-hot）类别表示。将其与估计结果进行比较，以获得整个网络的训练损失。</p>
<p>除了以上标准训练方式，作者还给出了一种单一图像训练方法，从而在图像目标检测数据集（如COCO和CrowdHuman）上训练FairMOT。这种方法仅将单个图像作为输入，并为每个边界框指定一个唯一的标识（id），从而将数据集中的每个对象实例视为一个单独的类。</p>
<h3 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h3><p>主要是如何将检测和re-ID关联起来。</p>
<h4 id="网络推理"><a href="#网络推理" class="headerlink" title="网络推理"></a>网络推理</h4><p>输入帧大小为1088×608，和JDE一样。在预测的热图之上，基于热图分数执行非极大值抑制（NMS），以提取峰值关键点。保留热图分数大于阈值的关键点的位置。然后根据估计的偏移量和框大小计算相应的边界框。</p>
<h4 id="在线关联（Online-Association）"><a href="#在线关联（Online-Association）" class="headerlink" title="在线关联（Online Association）"></a>在线关联（Online Association）</h4><p>和MOTDT方法一样，使用多层在线数据关联方法。首先根据第一帧中检测到的box初始化一些tracklets。然后在随后的帧中，使用<strong>两阶段</strong>匹配策略将检测到的box链接到现有的轨迹。</p>
<ul>
<li>在第一阶段，使用卡尔曼滤波和re-ID特征来获得初始跟踪结果。作者将马氏距离Dm与根据re-ID特征计算的余弦距离融合：D = λDr + (1 − λ)Dm，其中λ=0.98是权重参数。和JDE一样，如果马氏距离大于阈值，就将其设置为无穷大，以避免获得过大的运动轨迹。使用匹配阈值τ1=0.4的匈牙利算法完成第一阶段匹配。</li>
<li>在第二阶段，对于不匹配的检测和轨迹，我们尝试根据其框之间的重叠来匹配它们。特别是，我们将匹配阈值τ2设为0.5。最后，将不匹配检测初始化为新轨迹，并将不匹配的轨迹保存30帧，以备将来再次出现。</li>
</ul>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="数据集和指标"><a href="#数据集和指标" class="headerlink" title="数据集和指标"></a>数据集和指标</h3><p>ETH和CityPerson只提供框标注，所以只能用来训练检测分支。</p>
<p>CalTech、 MOT17、CUHK-SYSU和PRW提供了框和身份标注，可以用来训练两个分支。</p>
<p>衡量标准（benchmark）：2DMOT15、MOT16、MOT17和MOT20。</p>
<p>用平均精度（AP）来评估检测结果，用错误接受率（FAR）为0.1的真正例率（TPR）来评估re-ID特征。提取对应于GT框的re-ID特征，并使用每个特征检索N个最相似的候选。</p>
<p>评价指标：CLEAR和IDF1</p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>-MOT</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】GCN</title>
    <url>/gcn/</url>
    <content><![CDATA[<h1 id="本周工作"><a href="#本周工作" class="headerlink" title="本周工作"></a>本周工作</h1><h1 id="Graph-Convolutional-Networks-for-Temporal-Action-Localization-2019-ICCV"><a href="#Graph-Convolutional-Networks-for-Temporal-Action-Localization-2019-ICCV" class="headerlink" title="Graph Convolutional Networks for Temporal Action Localization [2019 ICCV]"></a>Graph Convolutional Networks for Temporal Action Localization [2019 ICCV]</h1><h2 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h2><p>目前二阶段TAL方法：首先生成一系列时序提名，再<strong>分别</strong>对每个提名做分类和边界回归。在这个learning过程中没有利用proposal之间的关系。但事实是，proposal之间的关系在TAL中扮演着非常重要的角色，于是作者提出使用Graph Convolutional Networks来探索proposal之间的关系。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="构建图"><a href="#构建图" class="headerlink" title="构建图"></a>构建图</h3><p><strong>上下文边（Contextual Edges）</strong></p>
<p>当 <img src="https://www.zhihu.com/equation?tex=r%28p_%7Bi%7D+%2Cp_%7Bj%7D%29%3E%5Ctheta_%7Bctx%7D" alt="[公式]"> ，我们就在proposal <img src="https://www.zhihu.com/equation?tex=p_%7Bi%7D" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=p_%7Bj%7D" alt="[公式]"> 之间建立一条边， 这里<img src="https://www.zhihu.com/equation?tex=%5Ctheta_%7Bctx%7D" alt="[公式]">是一个特定的阈值， <img src="https://www.zhihu.com/equation?tex=r%28p_%7Bi%7D+%2Cp_%7Bj%7D%29" alt="[公式]"> 代表proposal之间的相关性，被tIoU定义。</p>
<p><strong>周围边（Surrounding edges）</strong></p>
<p>上下文边将重叠proposal连接起来，而这些proposal通常对应相同的action instance。事实上，也可以将种类不同但是nearby的动作（包括背景）关联起来，并且它们之间传递的信息将有助于彼此检测。</p>
<p>为了处理这种相关性，我们首先利用 <img src="https://www.zhihu.com/equation?tex=r%28p_%7Bi%7D+%2Cp_%7Bj%7D%29%3D0" alt="[公式]"> 查询不同种类的提议，然后计算以下距离，如果 <img src="https://www.zhihu.com/equation?tex=d%28p_%7Bi%7D+%2Cp_%7Bj%7D%29%3C%5Ctheta_%7Bsur%7D" alt="[公式]"> 就在nearby proposals之间添加边。</p>
<p><img src="image-20220228193152721.png" alt="image-20220228193152721" style="zoom:80%;" /></p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="image-20220228201158024.png" alt="image-20220228201158024" style="zoom:80%;" /></p>
<p><img src="image-20220228201429808.png" alt="image-20220228201429808" style="zoom:80%;" /></p>
<h3 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h3><ol>
<li>在THUMOS14上的实验结果很好。</li>
<li>在activitynet上的结果仅仅利用P-GCN结果不是很好。添加了UntrimmedNet网络的结果才超过了BSN的结果。</li>
</ol>
<p><strong>思考</strong></p>
<p>在activitynet上可能是一个视频大部分都是只有一个动作，并且行为类别数比较多，不能很好的发挥提议与提议之间的关系。</p>
<h2 id="图卷积方法"><a href="#图卷积方法" class="headerlink" title="图卷积方法"></a>图卷积方法</h2><p>最大的贡献是发掘了proposal之间潜在的关系。</p>
<p>图的边是人为定的，可能存在误差。有没有可能把构建图的过程也变成网络学习的过程？</p>
<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><ul>
<li>目前对上学期的论文调研已经做了总结，接下来要尽快完成TAL领域的综述 并发表。（1~2个月）</li>
<li>时序动作定位领域继续学习新的论文、做实验，尽早确定具有可行性方法思路。（一项长期工作。计划：每周至少学习1~2篇论文，每两周完整地仿真一篇论文；所有论文阅读和实验做好整理和归纳）</li>
<li>希望可以结合一些具体的项目来进一步锻炼自己的代码能力。（如果有的话）</li>
</ul>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>-论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】Fast Learning of Temporal Action Proposal via Dense Boundary Generator</title>
    <url>/AcitonDBG/</url>
    <content><![CDATA[<h1 id="稠密边界视频动作检测器DBG：Fast-Learning-of-Temporal-Action-Proposal-via-Dense-Boundary-Generator-AAAI-2020"><a href="#稠密边界视频动作检测器DBG：Fast-Learning-of-Temporal-Action-Proposal-via-Dense-Boundary-Generator-AAAI-2020" class="headerlink" title="稠密边界视频动作检测器DBG：Fast Learning of Temporal Action Proposal via Dense Boundary Generator [AAAI 2020]"></a>稠密边界视频动作检测器DBG：Fast Learning of Temporal Action Proposal via Dense Boundary Generator [AAAI 2020]</h1><p>本文主要针对时序动作提名生成任务提出了一种新的方法：稠密边界生成器(Dense Boundary Generator, DBG)，能够<strong>端到端</strong>地生成高质量的时序动作提名。</p>
<p>BSN等基于概率序列的自下而上的方法，它生成开始和结束的时间概率序列，匹配概率峰值生成proposal，但是每个时间点只包含少量的<strong>局部</strong>信息，大概3~4s，因而无法处理复杂的活动和杂乱的背景，模糊边界定位不精确。</p>
<p>我们提出了密集边界生成器(DBG)，利用<strong>全局</strong>提案特征来预测边界图，并探索动作感知特征进行动作完整性分析。</p>
<p>给定一个长视频，DBG同时生成三个评分图（开始、结束和动作完整性评分图），密集地评估所有提议。</p>
<p><img src="image-20211122221510253.png" alt="image-20211122221510253"></p>
<h2 id="DBG框架结构"><a href="#DBG框架结构" class="headerlink" title="DBG框架结构"></a>DBG框架结构</h2><p><img src="image-20211122221111307.png" alt="image-20211122221111307"></p>
<h3 id="视频表示-Video-Representation"><a href="#视频表示-Video-Representation" class="headerlink" title="视频表示 Video Representation"></a>视频表示 Video Representation</h3><p>利用3D卷积网络提取视频的RGB特征和光流特征。</p>
<h3 id="密集边界生成器-Dense-Boundary-Generator"><a href="#密集边界生成器-Dense-Boundary-Generator" class="headerlink" title="密集边界生成器 Dense Boundary Generator"></a>密集边界生成器 Dense Boundary Generator</h3><p><strong>双流基网络 Dual Stream BaseNet</strong></p>
<p>输入是RGB特征和光流特征，输出是两种类型的特征：</p>
<ul>
<li>双流特征：low-level，L×128</li>
<li>动作评分特征：high-level，L×1</li>
</ul>
<p><strong>Action-aware completeness regression</strong></p>
<p>橙色的提案特征生成器分别生成两种特征组，上面一种L×L×32，L是视频特征序列的长度。最后输出预测动作完整性的分数图。</p>
<p>32的由来如下：分别对提案的开始和结束处扩展更多的区域，开始、动作和结束区域各采样8,16,8个点。</p>
<p><img src="image-20211122232735105.png" alt="image-20211122232735105"></p>
<p><strong>Temporal boundary classification</strong></p>
<p>L×L×128×32</p>
<p>最后将四维特征图处理为两个开始和结束的概率置信度图。</p>
<p><strong>后处理</strong></p>
<p>融合 开始分数×结束分数×完整性分数 作为提案的分数，再利用soft nms检索N个提案。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="image-20211123192610545.png" alt="image-20211123192610545"></p>
<h2 id="与BSN对比"><a href="#与BSN对比" class="headerlink" title="与BSN对比"></a>与BSN对比</h2><ul>
<li>本文是端到端</li>
<li><p>由一维边界概率序列变为二维分数图</p>
</li>
<li><p>本文引入动作提名特征生成层，该层能够有效捕获动作的全局特征，便于后面的分类和回归模块</p>
<p><img src="image-20211123200555494.png" alt="image-20211123200555494"></p>
</li>
</ul>
<h2 id="下周计划"><a href="#下周计划" class="headerlink" title="下周计划"></a>下周计划</h2><ol>
<li>继续调研论文，看看和本文思路相似的BMN和MGG</li>
<li>未来两周考试周，好好复习</li>
</ol>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】时序动作定位_一阶段方法_论文总结</title>
    <url>/oneStageTAL/</url>
    <content><![CDATA[<h1 id="End-to-end-Learning-of-Action-Detection-from-Frame-Glimpses-in-Videos-2016-CVPR"><a href="#End-to-end-Learning-of-Action-Detection-from-Frame-Glimpses-in-Videos-2016-CVPR" class="headerlink" title="End-to-end Learning of Action Detection from Frame Glimpses in Videos [2016 CVPR]"></a>End-to-end Learning of Action Detection from Frame Glimpses in Videos [2016 CVPR]</h1><p>视频动作检测任务中的<u>第一个</u>端到端方法。</p>
<p>该模型有一个基于递归神经网络的agent，它随着时间的推移与视频交互。agent观察固定比例的视频帧，并决定下一步在哪里看以及何时发出预测。</p>
<span id="more"></span>
<p><img src="image-20211008105534974.png" alt="image-20211008105534974"></p>
<p><strong>总体流程</strong></p>
<p>在某一步n中，agent观察橙色视频帧并产生3个输出：$(d_n, p_n, l_{n+1})$，分别表示（候选检测结果，预测指标，下一处观察位置）。其中，预测指标$p_n$输出“是”或“否”，指示$d_n$可否被作为一个预测结果被提交；候选检测结果$d_n$包括$(s_n, e_n, c_n)$，分别表示正则化开始、结束位置和该候选的置信度。</p>
<p>在上图中，$p_n$输出“否”，因此不被动作预测集接受。同时agent在n+1步中移动到$l_{n+1}$的位置，即绿色视频帧的位置，并继续产生3个输出：$(d_{n+1}, p_{n+1}, l_{n+2})$。此时$p_{n+1}$仍不被接受，因此agent在n+2步中移动到$l_{n+2}$的位置，即蓝色视频帧的位置。这次的$p_{n+2}$被接受，因此将该候选结果输入到动作预测集，同时agent继续下一步。</p>
<p>主要包含两个网络：</p>
<p>观察网络$f_o$对视频帧的视觉表示进行编码；循环网络$f_h$依次处理这些观察，并决定下一步观察哪个帧以及何时发出预测。</p>
<p><strong>观察网络$f_o$</strong></p>
<p>将视频帧中观察到的<u>地点和内容</u>编码为特征向量$O_n$ （通过卷积、池化、全连接等操作）。</p>
<p>输入：归一化处理后的时序位置。论文中使用VGG16。输出：特征向量$O_n$ 。</p>
<p><strong>循环网络$f_h$</strong></p>
<p>是agent的核心模块。</p>
<p>输入：特征向量$O_n$ 。输出：网络的隐藏状态$h_n$，它是$O_n$和前一隐藏状态$h_{n-1}$的函数，用来模拟动作实例的时间假设。</p>
<p><strong>训练</strong></p>
<p>使用反向传播训练$d_n$，使用REINFORCE训练$p_n$和$l_{n+1}$。</p>
<p><strong>优点</strong></p>
<p>只需要观察很少数的视频帧（2%甚至更少）</p>
<h1 id="SSAD-Single-Shot-Temporal-Action-Detection-2017-ACM-Multimedia"><a href="#SSAD-Single-Shot-Temporal-Action-Detection-2017-ACM-Multimedia" class="headerlink" title="(SSAD)Single Shot Temporal Action Detection [2017 ACM Multimedia]"></a>(SSAD)Single Shot Temporal Action Detection [2017 ACM Multimedia]</h1><p><strong>特征提取</strong></p>
<p>使用了双流网络和C3D网络来提取特征。拼接3个网络的最后一层（该层输出即代表输入snippet对应的每个动作的概率）输出作为后续使用的特征，该特征记作SAS（Snippet Action Score）特征。最终，对于一个包含T 帧图像的视频，我们可以得到等长的SAS特征序列。该特征序列实际上就是一个二维的矩阵。</p>
<p><img src="image-20211010193617009.png" alt="image-20211010193617009"></p>
<p><strong>SSAD模型</strong></p>
<p>输入：长度为T的特征序列。</p>
<p>SSAD模型是一个全部由时序卷积（一维卷积）构成的网络。主要包括三种卷积层：base, anchor, prediction layer。</p>
<p>Base Layers：缩短特征序列的长度，并增大特征序列中每个位置的感受野。</p>
<p>Anchor Layers ：继续缩小特征序列的长度，每层anchor layer输出的特征序列都被关联了多个尺度的anchor instances（类似SSD中的default box和faster RCNN中的anchor）。</p>
<p>Prediction Layers：获取每个anchor instances所对应的 坐标偏移量，重叠置信度，以及类别分类结果。</p>
<p>通过多层时间尺度不断缩小的特征序列，SSAD模型可以获得由小到大各个时间尺度的action instance预测。</p>
<p><img src="image-20211010193938188.png" alt="image-20211010193938188"></p>
<h1 id="SS-TAD-End-to-End-Single-Stream-Temporal-Action-Detection-in-Untrimmed-Videos-2017-BMVC"><a href="#SS-TAD-End-to-End-Single-Stream-Temporal-Action-Detection-in-Untrimmed-Videos-2017-BMVC" class="headerlink" title="(SS-TAD)End-to-End, Single-Stream Temporal Action Detection in Untrimmed Videos [2017 BMVC]"></a>(SS-TAD)End-to-End, Single-Stream Temporal Action Detection in Untrimmed Videos [2017 BMVC]</h1><p>模型由三个主要部分组成:输入视觉编码、两个循环记忆模块和最终输出。</p>
<p><img src="image-20211011161132357.png" alt="image-20211011161132357"></p>
<p><strong>视觉编码器：</strong></p>
<p>用C3D网络从输入的视频帧中获取较低层次的时空视觉信息。</p>
<p>将总长为L帧的视频分成T个不重叠的时间步，每个时间步内含有δ帧。每个时间步都进行视觉编码，得到φ。如上图。</p>
<p><strong>语义约束的循环记忆模块：</strong></p>
<p>有选择地聚合相关上下文。每个记忆模块包含了多层<u>门控循环单元</u>( gated recurrent unit， GRU)。如下图。</p>
<p><img src="image-20211011165733229.png" alt="image-20211011165733229"></p>
<p>该模块的一个关键：它们在训练过程中受到<u>语义约束</u>(Semantically Constrained)。</p>
<p>循环记忆模块有2个（P和C），分别负责捕捉proposal信息和classification信息。</p>
<p>输入：时间步t的视觉编码器输出φ以及前一个时间步的隐藏状态表示。</p>
<p>输出：最后一个GRU层在该模块中输出的隐藏状态h（如上图）。</p>
<p><strong>输出检测：</strong></p>
<p>输入：前一模块中，2个循环记忆模块的输出特征$h_{prop}$和$h_{cls}$进行连接，得到$h_{det}$。</p>
<p>输出：{起始，结束，分类}</p>
<h1 id="GTAN-Gaussian-Temporal-Awareness-Networks-for-Action-Localization-2019-CVPR"><a href="#GTAN-Gaussian-Temporal-Awareness-Networks-for-Action-Localization-2019-CVPR" class="headerlink" title="(GTAN)Gaussian Temporal Awareness Networks for Action Localization [2019 CVPR]"></a>(GTAN)Gaussian Temporal Awareness Networks for Action Localization [2019 CVPR]</h1><h2 id="movitation"><a href="#movitation" class="headerlink" title="movitation"></a>movitation</h2><p>很多方法是通过预先设计的固定的尺寸来生成动作的proposal（比如滑窗法、SSD等），这样做忽略了动作本身的时序结构，限制了检测复杂变化动作的能力。</p>
<p>本文提出，通过引入<strong>高斯核</strong>来动态优化每个动作提议的时间尺度来解决这个问题。</p>
<p>是一个one-stage方法。两阶段方法将proposal和classification分离可能导致次最优解（sub-optimal solutions）（为什么多阶段方法会影响结果的准确性？）。</p>
<p><img src="image-20211101195822052.png" alt="image-20211101195822052"></p>
<p><img src="image-20211101210605894.png" alt="image-20211101210605894"></p>
<h2 id="基础特征网络"><a href="#基础特征网络" class="headerlink" title="基础特征网络"></a>基础特征网络</h2><p>输入视频帧，通过3D-CNN提取帧级的特征（一个cell），并连接。然后经过两个1D时序卷积和一个max-pooling进一步增加感受野。</p>
<h2 id="高斯核学习"><a href="#高斯核学习" class="headerlink" title="高斯核学习"></a><strong>高斯核学习</strong></h2><p>为每个cell生成一个高斯核。具体地，定义feature map为</p>
<p><img src="image-20211101210229152.png" alt="image-20211101210229152"></p>
<p>其中 <img src="https://www.zhihu.com/equation?tex=T%5E%7Bj%7D" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=D%5E%7Bj%7D" alt="[公式]"> 为时序长度和特征维度。对于一个proposal <img src="https://www.zhihu.com/equation?tex=P_t%5E%7Bj%7D" alt="[公式]"> ，中间位置为 <img src="https://www.zhihu.com/equation?tex=t" alt="[公式]"> , 通过一个高斯核 <img src="https://www.zhihu.com/equation?tex=G_t%5Ej" alt="[公式]"> 来刻画它的时序尺度。通过一个1D 卷积层来学习标准差 <img src="https://www.zhihu.com/equation?tex=%5Csigma_t%5Ej" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=G_t%5Ej" alt="[公式]"> 可定义如下：</p>
<p><img src="image-20211101210334652.png" alt="image-20211101210334652"></p>
<p>其中， Z为归一化常量。标准差 <img src="https://www.zhihu.com/equation?tex=%5Csigma_%7Bt%7D%5E%7Bj%7D" alt="[公式]"> 可以考虑作为高斯核 <img src="https://www.zhihu.com/equation?tex=G_%7Bt%7D%5E%7Bj%7D" alt="[公式]"> 宽度的测量。然后我们可以通过 <img src="https://www.zhihu.com/equation?tex=%5Csigma_t%5Ej" alt="[公式]"> 来获得时序边界：</p>
<p><img src="image-20211101210516704.png" alt="image-20211101210516704"></p>
<p>其中 <img src="https://www.zhihu.com/equation?tex=a_c+" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=a_w" alt="[公式]"> 为时序边界的中心和宽度。</p>
<h2 id="高斯核合并"><a href="#高斯核合并" class="headerlink" title="高斯核合并"></a><strong>高斯核合并</strong></h2><p>如果两个高斯核的IoU大于设定的阈值，则进行合并。</p>
<p><img src="image-20211101210631593.png" alt="image-20211101210631593"></p>
<p>新合并的高斯核如下：</p>
<p><img src="image-20211101210714733.png" alt="image-20211101210714733"></p>
<h2 id="高斯池化"><a href="#高斯池化" class="headerlink" title="高斯池化"></a><strong>高斯池化</strong></h2><p><img src="image-20211101210746585.png" alt="image-20211101210746585"></p>
<p><img src="image-20211101210815021.png" alt="image-20211101210815021"></p>
<p>其中<img src="https://www.zhihu.com/equation?tex=F_t%5Ej" alt="[公式]"> 被用于后续的动作识别和时序边界回归。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="image-20211101213043935.png" alt="image-20211101213043935"></p>
<h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><p>加高斯核的方式有点像加Attention （但是二者有哪些具体的区别？）</p>
<p>很多方法都是共通的。比如在论文Background Modeling中，也提到用高斯核</p>
<p>多阅读多扩宽知识面，更能发现论文的问题</p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>博客使用指南</title>
    <url>/cl5gc8axf001decu99tnt8cf4/</url>
    <content><![CDATA[<h1 id="从创建到部署"><a href="#从创建到部署" class="headerlink" title="从创建到部署"></a>从创建到部署</h1><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo n <span class="string">&quot;博客使用指南&quot;</span></span><br><span class="line">$ hexo new <span class="string">&quot;博客使用指南&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>默认情况下，访问网址为： <code>http://localhost:4000/</code></p>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h2 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<span id="more"></span>
<h1 id="设置标签"><a href="#设置标签" class="headerlink" title="设置标签"></a>设置标签</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> tages: </span><br><span class="line">- 标签<span class="number">1</span></span><br><span class="line">- 标签<span class="number">2</span></span><br><span class="line">...</span><br><span class="line">- 标签n</span><br></pre></td></tr></table></figure>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">tages: [标签<span class="number">1</span>,标签<span class="number">2</span>,...标签n]</span><br></pre></td></tr></table></figure>
<h1 id="手动设置文章时间"><a href="#手动设置文章时间" class="headerlink" title="手动设置文章时间"></a>手动设置文章时间</h1><p>直接在文章开头设置发表/更新时间：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">date: <span class="number">2021</span>-<span class="number">09</span>-<span class="number">03</span> <span class="number">15</span>:<span class="number">02</span>:<span class="number">51</span></span><br><span class="line">updated: <span class="number">2018</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客使用</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】时序动作定位-弱监督方法-论文总结</title>
    <url>/WeaklyTAL/</url>
    <content><![CDATA[<h1 id="弱监督方法"><a href="#弱监督方法" class="headerlink" title="弱监督方法"></a>弱监督方法</h1><p>特点：</p>
<ul>
<li>直接使用未剪切的视频进行学习，而不需要时序标注。</li>
<li>只需要视频级的标签。</li>
</ul>
<h1 id="UntrimmedNets-for-Weakly-Supervised-Action-Recognition-and-Detection-CVPR-2017"><a href="#UntrimmedNets-for-Weakly-Supervised-Action-Recognition-and-Detection-CVPR-2017" class="headerlink" title="UntrimmedNets for Weakly Supervised Action Recognition and Detection (CVPR 2017)"></a>UntrimmedNets for Weakly Supervised Action Recognition and Detection (CVPR 2017)</h1><p>UntrimmedNet首次提出弱监督用于动作识别和检测。</p>
<p><img src="image-20211016213917815.png" alt="image-20211016213917815" style="zoom:67%;" /></p>
<span id="more"></span>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>如下图，首先生成clip proposals，即从视频中采样出较短的clips集合。然后将这些clip proposals输入到预训练好的网络中进行特征提取。之后，使用一个分类模块（Classification）来对每个clip proposal进行行为识别，以及一个选择模块（Selection）来检测或排序重要的clip proposals。最后，结合分类模块和选择模块的输出来产生视频级别的预测。</p>
<p><img src="image-20211016214120582.png" alt="image-20211016214120582"></p>
<h2 id="Clip-sampling"><a href="#Clip-sampling" class="headerlink" title="Clip sampling"></a>Clip sampling</h2><p>给定一个长视频V，将其分割成N个clip proposals。</p>
<p>两种方法：</p>
<ul>
<li>均匀采样：将长视频平均分成N个等长的clips。</li>
<li>基于镜头采样：提取每一帧的HOG特征，如果相邻帧之间的HOG特征区别大于某个阈值，即检测到了一个shot change。在每个shot内部，如果该shot的时间过长，则将其细分为多个等长的clips，每个clip的长度为K帧（K=300）。</li>
</ul>
<h2 id="UntrimmedNets"><a href="#UntrimmedNets" class="headerlink" title="UntrimmedNets"></a>UntrimmedNets</h2><p>由3个模块组成：特征提取模块、分类模块和选择模块。</p>
<h3 id="特征提取模块"><a href="#特征提取模块" class="headerlink" title="特征提取模块"></a>特征提取模块</h3><p>在该模块，为每个proposal提取特征表示。UntrimmedNet不依赖于某个特定的特征提取网络。文章尝试了两个结构：Two-stream CNN和Temporal Segment Network，后者的spatial stream的输入是1个RGB帧，而temporal stream的输入是5帧TVL1 optical flow。</p>
<h3 id="分类模块"><a href="#分类模块" class="headerlink" title="分类模块"></a>分类模块</h3><p>根据前一个模块提取到的特征，对每个clip proposal进行动作分类。最终给出每个proposal对C个动作类别的得分向量（score vector）$x^c$。另外再对所有$x^c$做一个softmax得到$\overline{x}^c$：</p>
<script type="math/tex; mode=display">
\overline{x}^c_i=\frac{exp(x^c_i)}{\sum_{k=1}^{C} exp(x^c_k)}</script><p>原始分类score（$x^c$）含有原始的class activation信息，能反映该clip含有一个行为类别的程度。如果不包含行为，则它在每个类别上的值都会很小；softmax分类score（$\overline{x}^c$）由于经过了正则化操作，不能正确表示不含有任何行为的情况。</p>
<h3 id="选择模块"><a href="#选择模块" class="headerlink" title="选择模块"></a>选择模块</h3><p>选择模块的目标是选择出最有可能包含动作的clip proposals。论文提出两种选择方法：<u>硬选择</u>（hard selection，基于multiple instance learning 多示例学习，MIL）和<u>软选择</u>（soft selection，基于attention机制）。</p>
<ul>
<li>硬选择方法：为每个动作类别识别出k个clip proposals子集合。选择k个分类得分$x^c$最高的proposals，然后对这些proposals求平均。</li>
<li>软选择方法：结合所有clip proposals的分类得分，学习得到重要性权重（importance weight）来对clip proposals进行排序。最终给出每个proposal经注意力权重后算出的<u>选择得分</u>（selection score）$x^s$。与前一模块相似，另外再对所有$x^s$做一个softmax得到$\overline{x}^s$。</li>
</ul>
<p>需要注意的是，在<u>分类模块</u>中，softmax是对每个的proposal的所有类别的classification score进行操作；而在<u>选择模块</u>中，softmax是对不同的proposal进行操作。</p>
<h3 id="视频预测"><a href="#视频预测" class="headerlink" title="视频预测"></a>视频预测</h3><p>通过结合<u>分类得分</u>和<u>选择得分</u>来生成视频V的<u>预测得分</u> $\overline{x}^p$。</p>
<ul>
<li><p>对于硬选择方法，简单地对选出的top-k instances取平均</p>
</li>
<li><p>对于软选择方法，简单地计算<u>分类得分</u>和<u>选择得分</u>的乘积的加权和：</p>
</li>
</ul>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>使用交叉熵损失进行反向传播从而训练模型各模块的参数。</p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><strong>动作识别结果：</strong></p>
<p><img src="image-20211016231819620.png" alt="image-20211016231819620"></p>
<p><strong>动作定位结果：</strong></p>
<p>IoU@0.5=13.7</p>
<p><img src="image-20211016231923145.png" alt="image-20211016231923145"></p>
<p><strong>缺点/问题：</strong>因为是第一篇提出弱监督的方法，所以精度还是很低。</p>
<h1 id="STPN-Weakly-Supervised-Action-Localization-by-Sparse-Temporal-Pooling-Network-2018-CVPR"><a href="#STPN-Weakly-Supervised-Action-Localization-by-Sparse-Temporal-Pooling-Network-2018-CVPR" class="headerlink" title="(STPN)Weakly Supervised Action Localization by Sparse Temporal Pooling Network (2018 CVPR)"></a>(STPN)Weakly Supervised Action Localization by Sparse Temporal Pooling Network (2018 CVPR)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>文章认为，通过识别视频中的重要动作的一组关键片段，可识别出其中的动作。 因此，文章设计了一个神经网络，学习如何度量视频中每个片段的重要性，并自动选择具有代表性的片段的稀疏子集来预测视频级的类别。预测时，首先确定视频的类别，然后生成时序动作proposals。</p>
<p>其网络大致结构如下。将视频<strong>均分</strong>为N个segment；最后能够得出每个片段在预测分类标签过程中的重要程度，从而生成对应的类别标签以及区域建议。</p>
<p><img src="image-20211018203426583.png" alt="image-20211018203426583"></p>
<h2 id="动作分类"><a href="#动作分类" class="headerlink" title="动作分类"></a>动作分类</h2><p>将训练视频均分为T个segment（作者在实际训练中T=400）。每个segment通过I3D得到维度T×1024的特征，通过一个attention module（注意力模块）生成对应segment的重要性。其中attention module（上图右下角）由两个全连接层以及一个ReLU层组成，然后经过Sigmoid后范围为0-1之间，输出维度为T×1，最后通过注意力权重与segment特征的加权和得到最终的视频特征表示，其表示为</p>
<p><img src="image-20211018204047435.png" alt="image-20211018204047435"></p>
<p>其中$x_t$代表第$t$个segment的视频表示， $\lambda_t$表示为对应$x_t$的权重向量， $T$为该视频segments的数量。由于一个视频可能包含多个动作实例，因此再通过Sigmoid函数而不是softmax函数得到最终包含多个动作类别概率。 而针对于loss函数设计，作者考虑到attention module中注意力权重是接近于0或1的数值，因此作者loss函数由两部分组成， 分别为分类损失和稀疏损失。分类损失是基于ground-truth和$\overline{x}$之间标准的多标签交叉熵损失,而稀疏损失则由$l_1$损失函数组成。</p>
<h2 id="Temporal-Class-Activation-Mapping"><a href="#Temporal-Class-Activation-Mapping" class="headerlink" title="Temporal Class Activation Mapping"></a>Temporal Class Activation Mapping</h2><p>为了确定与目标时间对应的时间区间，作者提出了一个叫做T-CAM的概念，表示时间步$t$时刻的该表示与各个类别的<strong>相关性</strong>。 作者在下图给出了视频attention weights和T-CAM的输出实例，attention weights和T-CAM有效地突出了各个时序区域。</p>
<p>一些具有较大定位权重的时间间隔不对应于较大的T-CAM值，因为这些间隔可能代表了其他干扰行为。attention weights测量时间视频片段的泛化动作，而T-CAM呈现类别特定信息。</p>
<p><img src="image-20211018211504932.png" alt="image-20211018211504932"></p>
<h2 id="时序动作定位"><a href="#时序动作定位" class="headerlink" title="时序动作定位"></a>时序动作定位</h2><p>为了生成 temporal proposals，作者将光流flow和RGB图像分别送入网络，其输出与注意力权重相乘，然后得到加权后的T-CAM，通过给定阈值来分割出对应的action proposals。最后通过非极大值抑制生成最终的proposals。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="image-20211018215633190.png" alt="image-20211018215633190"></p>
<p><strong>问题：</strong>Segment是人为划分且是均匀划分，是否会对结果有所影响呢？</p>
<h1 id="CMCS-Completeness-Modeling-and-Context-Separation-for-Weakly-Supervised-Temporal-Action-Localization-2019-CVPR"><a href="#CMCS-Completeness-Modeling-and-Context-Separation-for-Weakly-Supervised-Temporal-Action-Localization-2019-CVPR" class="headerlink" title="(CMCS)Completeness Modeling and Context Separation for Weakly Supervised Temporal Action Localization (2019 CVPR)"></a>(CMCS)Completeness Modeling and Context Separation for Weakly Supervised Temporal Action Localization (2019 CVPR)</h1><p>动作完整性建模和动作上下文分离</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>弱监督导致的两个问题：动作完整性建模和动作上下文分离。</p>
<p><strong>弱监督TAL的两大挑战</strong></p>
<ol>
<li>如何在没有完整注释的情况下检测出完整的动作实例。识别出动作的一个片段足以进行视频级分类，但不能进行片段级定位。比如，“罚点球”这一动作由“射门”和“球飞”这两个子动作组成，只要能识别出“射门”便可对这个视频进行分类，但要想定位“罚点球”的片段，“球飞”子动作很容易被漏掉。</li>
<li>如何用弱标签将动作实例与其上下文区分开来。<strong>在同一类动作实例的前后，通常存在一些在视觉上相似的镜头画面，</strong>这些画面被称为<strong>上下文（context）</strong>。比如，对“打台球”这一动作，在视频中往往存在镜头对着台球桌的静态画面。上下文和背景的区别是：上下文画面通常与真实动作同时出现，不涉及其他动作类别的视频；而背景画面是类别无关的，随机分布。文章认为，除非使用关于动作的先验知识，否则在弱监督情况下，动作—上下文分离本质上是困难的。</li>
</ol>
<p>针对这两个问题，分别提出了多分支网络结构和难负例数据生成方案。</p>
<h2 id="难负例数据生成"><a href="#难负例数据生成" class="headerlink" title="难负例数据生成"></a>难负例数据生成</h2><p>弱监督模型倾向于将真实动作与其上下文context相混淆，也就是hard negatives（可以理解为容易将负样本看成正样本的那些样本）。利用“静止的视频片段不太可能是动作”这一先验，为训练生成难负例数据。光流强度小于一个阈值（差不多是静止的画面）则把这个视频中的这些帧提取出来构成伪视频，并标记为背景类，添加到训练集中。</p>
<h2 id="基于多分支网络的完整性建模"><a href="#基于多分支网络的完整性建模" class="headerlink" title="基于多分支网络的完整性建模"></a>基于多分支网络的完整性建模</h2><p>多分支网络包括：特征提取模块、嵌入模块、多分支分类模块和时序注意力模块。</p>
<p><img src="image-20211024163047504.png" alt="image-20211024163047504"></p>
<h3 id="特征提取模块-1"><a href="#特征提取模块-1" class="headerlink" title="特征提取模块"></a>特征提取模块</h3><p>将视频分为T个snippets，进行特征提取。文中使用的是UntrimmedNet和 I3D 。</p>
<h3 id="嵌入模块"><a href="#嵌入模块" class="headerlink" title="嵌入模块"></a>嵌入模块</h3><p>以上提取的特征需要特定于本任务的特征嵌入。利用一个时序卷积层和一个ReLU激活层来嵌入特征。</p>
<h3 id="多分支分类模块"><a href="#多分支分类模块" class="headerlink" title="多分支分类模块"></a>多分支分类模块</h3><p>在这个模块中，存在K个并行的分类分支，目的是让各个分支关注动作的不同部分，让每个分支更准确的反映当前分支的动作分布情况，也就是说，这几个分支应是互补的，可以反映出其他分支没有的信息。</p>
<p>每个分支将嵌入的特征序列输入到时序卷积层，得到C+1个类别的分类得分 $A_k$，再通过softmax输出<u>类别激活序列</u> $\overline{A}_k$。</p>
<p>为了避免各个分支给出相似的CAS，必须对分支加以约束。文中使用了基于余弦相似度的多样性损失。（对于两个向量，余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似；越接近0，就表明夹角越接近90度，也就是两个向量越不相似）</p>
<p>最后对所有分支的CAS进行平均，并进行softmax。</p>
<p>如下图所示，a是真值；b是负责定位“射门”的CAS；c是负责定位“球飞”的CAS；d是CAS的平均，从而完整识别出整个动作。</p>
<p><img src="image-20211024154109036.png" alt="image-20211024154109036"></p>
<h3 id="时序注意力模块"><a href="#时序注意力模块" class="headerlink" title="时序注意力模块"></a>时序注意力模块</h3><p><img src="image-20211024173940638.png" alt="image-20211024173940638"></p>
<p>输入的视频未经修剪，且包含无关背景。所以利用时序注意力模块学习各snippets的重要性权重。注意力权重与<u>多分支分类模块</u>中经平均后的CAS做加权和。最终输出长度为C+1的向量。然后计算其与GT的交叉熵，即标准MIL损失。</p>
<h2 id="动作定位"><a href="#动作定位" class="headerlink" title="动作定位"></a>动作定位</h2><p>实际中，一段视频可能含有不止一个类别，因此需设置阈值，当某一类别的得分高于阈值的时候才认为视频中出现了该类别。</p>
<h2 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h2><p>THUMOS’14 </p>
<p><img src="image-20211024194025208.png" alt="image-20211024194025208"></p>
<p>ActivityNet1.3</p>
<p><img src="image-20211024194102049.png" alt="image-20211024194102049"></p>
<h1 id="Background-Modeling-Weakly-supervised-Action-Localization-with-Background-Modeling-2019-ICCV"><a href="#Background-Modeling-Weakly-supervised-Action-Localization-with-Background-Modeling-2019-ICCV" class="headerlink" title="(Background Modeling)Weakly-supervised Action Localization with Background Modeling (2019 ICCV)"></a>(Background Modeling)Weakly-supervised Action Localization with Background Modeling (2019 ICCV)</h1><p>同为STPN的作者</p>
<h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>大多数之前的弱监督工作忽略了背景，但本文发现，对<strong>背景建模</strong>可以学习到更为丰富的动作理解及其时序范围。</p>
<p>许多网络使用一个注意力变量 $\lambda_t$ 来指定各帧在最终的视频级表示中所占的权重。而本文用$1-\lambda_t$ 来表示背景帧的权重，构建了一个聚合的视频级特征。</p>
<p>本文的创新</p>
<ul>
<li>使用注意力模型来提取前景和背景帧，它们的外观被明确地建模。大多数之前的弱监督工作忽略了背景，许多网络使用一个注意力变量 $\lambda_t$ 来指定各帧在最终的视频级表示中所占的权重。但本文发现，对<strong>背景建模</strong>可以学习到更为丰富的动作理解及其时序范围，类似地，本文用$1-\lambda_t$ 来表示背景帧的权重。</li>
<li>将<u>自底向上的、类别无关的注意力模块</u>与<u>自顶向下的、特定类别的激活图</u>结合起来，使用后者作为前者的自监督形式。</li>
<li>小视频补充训练。社交平台上有大量小视频，用户发送小视频的时候常常会带相关的话题，可以粗略地将这些话题作为视频级标签，以扩充训练数据。本文表明，在现有的训练数据中添加小视频可以大幅增加学习效果，从而提高动作定位的准确性。</li>
</ul>
<p><img src="image-20211026191157303.png" alt="image-20211026191157303"></p>
<h2 id="弱监督定位"><a href="#弱监督定位" class="headerlink" title="弱监督定位"></a>弱监督定位</h2><p>训练数据表示为$(\{x_t\},y)$，即（视频第t帧的特征向量，视频级标签）。</p>
<p><strong>Weak Supervision</strong></p>
<p>对整个视频的帧特征进行注意力加权平均，得到视频级的前景特征$x_{fg}$：</p>
<p><img src="image-20211024215311965.png" alt="image-20211024215311965"></p>
<p>对每个类别c，做softmax：</p>
<p><img src="image-20211025172750868.png" alt="image-20211025172750868"></p>
<p>计算前景分类损失：</p>
<p><img src="image-20211025172734151.png" alt="image-20211025172734151"></p>
<p><strong>背景感知（Background-Aware）损失</strong></p>
<p>对于背景帧，也应该做同样的处理</p>
<p><img src="image-20211025173432506.png" alt="image-20211025173432506"></p>
<p><img src="image-20211025173609108.png" alt="image-20211025173609108"></p>
<p><img src="image-20211025173755005.png" alt="image-20211025173755005"></p>
<p>这里y=0是因为0被当作是背景类。</p>
<p><strong>自引导注意力（Self-guided Attention）损失</strong></p>
<p>$\lambda_t$ 是一个自下而上的，类别无关的attention，它可能会响应一些一般线索，如大型的肢体动作，而不会具体到一些特定的动作。而TCAM可以提取自顶向下的attentional线索。因此，提出类特定的TCAM attention map作为自监督重新微调$\lambda_t$，如下式。其中G(σ)是高斯过滤器，用于在时序上平滑attention信号。高斯平滑强加了直观的先验：如果一个帧大概率是一个动作，那它的邻近帧也应该大概率包含一个动作。</p>
<p><img src="image-20211025185847408.png" alt="image-20211025185847408"></p>
<p><img src="image-20211025190850555.png" alt="image-20211025190850555"></p>
<p>则自引导损失：</p>
<p><img src="image-20211025190940914.png" alt="image-20211025190940914"></p>
<p><strong>前景背景聚类（Foreground-background Clustering）损失</strong></p>
<p>考虑了一个完全由视频特征和注意力λ定义的自下而上的损失，鼓励分类器对前景或背景特征响应强烈。</p>
<p><img src="image-20211025192908529.png" alt="image-20211025192908529"></p>
<p><strong>总损失</strong></p>
<p><img src="image-20211025193237733.png" alt="image-20211025193237733"></p>
<p>3个超参要足够小，以使网络主要由前景损失来驱动。</p>
<h2 id="动作定位-1"><a href="#动作定位-1" class="headerlink" title="动作定位"></a>动作定位</h2><p>为了生成动作proposals和detections，首先基于视频级分类概率$p_{fg}$识别相关动作类别。然后用相应的加权t-cam对这些提议进行评分，以获得最终的检测结果。</p>
<p>最后进行NMS非极大值抑制。</p>
<p><strong>与CTPN的比较</strong></p>
<p><img src="image-20211025195336729.png" alt="image-20211025195336729"></p>
<h1 id="BaSNet-Background-Suppression-Network-for-Weakly-Supervised-Temporal-Action-Localization-2020-AAAI"><a href="#BaSNet-Background-Suppression-Network-for-Weakly-Supervised-Temporal-Action-Localization-2020-AAAI" class="headerlink" title="(BaSNet) Background Suppression Network for Weakly-Supervised Temporal Action Localization (2020 AAAI)"></a>(BaSNet) Background Suppression Network for Weakly-Supervised Temporal Action Localization (2020 AAAI)</h1><p>为了构建背景类的负样本，在网络中引入注意力模块<strong>抑制背景</strong>响应。</p>
<h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>发现之前的工作没有考虑到背景类别，会将背景帧误分为动作类别，造成大量FP。本文提出了背景抑制网络BaSNet，引入了额外的背景类，两支镜像网络(一支为base网络，一支为用attention抑制背景的suppression网络)，实验表明这样设计可以有效抑制背景的影响，从而提高定位的准确性。</p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><h3 id="背景类"><a href="#背景类" class="headerlink" title="背景类"></a>背景类</h3><p>如果没有背景类，背景帧的激活会倾向于动作类，对精确定位造成干扰。因此，<strong>将背景归为“背景类”</strong>，也就是说，视频中的所有帧就都有自己的目标类别。这样，所有训练视频都会被标记为背景类的正样本（因为每个视频都包含背景帧）。这会造成数据不平衡（找不到完全没有背景的负样本），最后导致背景类的异常高响应，定位结果很差。因此，为了更好地利用背景类，我们设计了包含基分支和抑制分支的背景抑制网络(BaS-Net)。</p>
<p><img src="image-20211025205411717.png" alt="image-20211025205411717"></p>
<h3 id="双分支结构"><a href="#双分支结构" class="headerlink" title="双分支结构"></a>双分支结构</h3><ul>
<li><p>基分支（base branch）：采用常用的MIL架构，以帧级特征作为输入，生成帧级<u>类别激活序列</u>(CAS)，将视频分类为动作类和背景类的正样本。</p>
</li>
<li><p>抑制分支（suppression branch）：首先经过一个注意力模块（filtering module），用于减小来自背景帧的输入特征，即抑制背景的响应。attention模块参考自STPN (CVPR2018) ，将fc换成时域卷积，并且与STPN的attention输入为单个clip特征不同，本文的attention的输入为视频特征。经过过滤模块后，是与基分支相同的共享权重的卷积模块。抑制分支的目标是最小化所有视频的背景类得分。</p>
</li>
</ul>
<p><img src="image-20211025212535348.png" alt="image-20211025212535348"></p>
<p>这两个分支唯一的不同点就是<strong>输入</strong>(抑制分支的输入经过attention处理)和<strong>background label</strong>(<u>基分支</u>的背景类为1，<u>抑制分支</u>的背景类为0) 这两点不同。这样做的目标是更好的训练filtering module使其学到前景信息，从而有效过滤并抑制背景的响应。</p>
<p>最后的location模块在测试阶段选取supp分支的输出。后续操作仍然采用多阈值分割后NMS的方式。</p>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>周界入侵调研</title>
    <url>/zhoujieruqin/</url>
    <content><![CDATA[<h1 id="高铁危情识别——周界入侵"><a href="#高铁危情识别——周界入侵" class="headerlink" title="高铁危情识别——周界入侵"></a>高铁危情识别——周界入侵</h1><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul>
<li><p>采用在线多目标跟踪的方式进行周界入侵的检测以及运动轨迹的分析，选择<strong>FairMOT</strong>作为基础网络，针对夜间、小目标等难点进行优化，配合报警逻辑完成周界入侵的监控任务。</p>
</li>
<li><p>针对轨迹匹配出错的问题，选择<strong>ByteTrack</strong>作为补充。</p>
</li>
</ul>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><h3 id="夜间"><a href="#夜间" class="headerlink" title="夜间"></a>夜间</h3><p>光照条件不足，对比度偏低，颜色信息退化严重，亮度和信噪比都相对较低，造成了图像感知质量大幅度降低。</p>
<h3 id="小目标"><a href="#小目标" class="headerlink" title="小目标"></a>小目标</h3><p>分辨率低，图像模糊，包含较少的信息，由此导致特征表达能力弱。</p>
<h3 id="复杂背景"><a href="#复杂背景" class="headerlink" title="复杂背景"></a>复杂背景</h3><p>铁轨两侧的环境复杂，杂草，石头，甚至护栏会产生复杂的背景环境。一方面，导致误检，产生错误的报警，另一方面，复杂背景会与需检测的行人混淆，影响目标检测的效果。</p>
<h3 id="检测不连续"><a href="#检测不连续" class="headerlink" title="检测不连续"></a>检测不连续</h3><p>在检测效果不稳定的时间内，跟踪效果会受到较大的影响，在检测多帧丢失的情况下，将丢失的轨迹与新的检测目标匹配起来是较为困难的任务。</p>
<h3 id="报警逻辑"><a href="#报警逻辑" class="headerlink" title="报警逻辑"></a>报警逻辑</h3><p>周界外的目标的检出会影响报警的准确性；周界内的目标，报警逻辑需要面对检测不稳定，跟踪无法匹配，背景误检等特殊情况。</p>
<h3 id="低分目标难以匹配"><a href="#低分目标难以匹配" class="headerlink" title="低分目标难以匹配"></a>低分目标难以匹配</h3><h2 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h2><ul>
<li>传统方法</li>
<li>深度学习方法</li>
</ul>
<p><img src="/image-20220630231242919.png" alt="image-20220630231242919"></p>
]]></content>
      <categories>
        <category>周界入侵</category>
      </categories>
      <tags>
        <tag>-周界入侵</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习笔记</title>
    <url>/cl5gc8axh001oecu9d422cj9p/</url>
    <content><![CDATA[<h3 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h3><span id="more"></span>
<p>对于一个函数来说，通常有两种计算梯度的方式：</p>
<ul>
<li>数值梯度（numerical gradient）;</li>
<li>解析梯度（analytic gradient）;</li>
</ul>
<p><strong>数值梯度</strong>的优点是容易编程实现，不要求函数可微。然而，<strong>数值梯度</strong>缺点很明显，通常是近似解，同时求解速度很慢，因此在设计机器学习目标函数时，通常设计成可微的函数，可以快速地求解其<strong>解析梯度</strong>，同时这个梯度是确切解。</p>
<p>神经网络算法使用反向传播计算目标函数关于每个参数的梯度，可以看做<strong>解析梯度</strong>。由于计算过程中涉及到的参数很多，反向传播计算的梯度很容易出现误差，导致最后迭代得到效果很差的参数值。</p>
<p>为了确认代码中反向传播计算的梯度是否正确，可以采用<strong>梯度检验（gradient check）</strong>的方法。通过计算数值梯度，得到梯度的近似值，然后和反向传播得到的梯度进行比较，若两者相差很小的话则证明反向传播的代码是正确无误的。</p>
<p>误差在10^-7说明正确；误差在10^-3说明很可能有问题。</p>
<p>梯度检验通常在调试代码时用，训练时不用（因为太慢）。</p>
<p>不要和Dropout一起用，因为后者没有确定的代价函数。</p>
<h3 id="torch保存和读取模型"><a href="#torch保存和读取模型" class="headerlink" title="torch保存和读取模型"></a>torch保存和读取模型</h3><p>假设网络为<code>model = Net()</code>， <code>optimizer = optim.Adam(model.parameters(), lr=args.lr)</code>。假设在某个epoch，我们要保存模型参数，优化器参数以及epoch。</p>
<p>一、</p>
<ol>
<li>先建立一个字典，保存三个参数：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">state = &#123;<span class="string">&#x27;net&#x27;</span>: model.state_dict(), <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict(), <span class="string">&#x27;epoch&#x27;</span>: epoch&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调用torch.save():</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(state, <span class="built_in">dir</span>)</span><br></pre></td></tr></table></figure>
<p>其中<code>dir</code>表示保存文件的路径+保存文件名，如’/home/modelpara.pth’</p>
<p>二、</p>
<p>当你想恢复某一阶段的训练（或者进行测试）时，那么就可以读取之前保存的网络模型参数等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">checkpoint = torch.load(<span class="built_in">dir</span>)</span><br><span class="line">model.load_state_dict(checkpoint[<span class="string">&#x27;net&#x27;</span>])</span><br><span class="line">optimizer.load_state_dict(checkpoint[<span class="string">&#x27;optimizer&#x27;</span>])</span><br><span class="line">start_epoch = checkpoint[<span class="string">&#x27;epoch&#x27;</span>] + <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体排序-ccf1709-2公共钥匙盒</title>
    <url>/cl5gc8axl001recu917h61okt/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>N个挂钩上有N个钥匙。钥匙没有固定的悬挂位置，但钥匙上有标号。</p>
<p>每次取钥匙的时候，而不会移动其他钥匙。</p>
<p>每次还钥匙的时候，挂在<strong>最左边的空挂钩</strong>上。</p>
<p>同一时刻<strong>先还再取</strong>，且按<strong>编号从小到大</strong>的顺序还。</p>
<p>初始时，钥匙按编号<strong>从小到大</strong>挂着。</p>
<p>有<em>K</em>位老师取。给出钥匙标号、取出时间和借出时长，请问最终钥匙盒里面钥匙的顺序是怎样的？</p>
<span id="more"></span>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>　　输入的第一行包含两个整数<em>N</em>, <em>K</em>。<br>　　接下来<em>K</em>行，每行三个整数<em>w</em>, <em>s</em>, <em>c</em>，分别表示一位老师要使用的钥匙编号、取出时间和借出的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>　　输出一行，包含<em>N</em>个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。</p>
<h1 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h1><p>5 2<br>4 3 3<br>2 2 7</p>
<h1 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h1><p>1 4 3 2 5</p>
<h1 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h1><p>　　第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。<br>　　每个关键时刻后的钥匙状态如下（X表示空）：<br>　　时刻2后为1X345；<br>　　时刻3后为1X3X5；<br>　　时刻6后为143X5；<br>　　时刻9后为14325。</p>
<h1 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h1><p>5 7<br>1 1 14<br>3 3 12<br>1 15 12<br>2 7 20<br>3 18 12<br>4 21 19<br>5 30 9</p>
<h1 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h1><p>1 2 3 5 4</p>
<h1 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h1><p>　　对于30%的评测用例，1 ≤ <em>N</em>, <em>K</em> ≤ 10, 1 ≤ <em>w</em> ≤ <em>N</em>, 1 ≤ <em>s</em>, <em>c</em> ≤ 30；<br>　　对于60%的评测用例，1 ≤ <em>N</em>, <em>K</em> ≤ 50，1 ≤ <em>w</em> ≤ <em>N</em>，1 ≤ <em>s</em> ≤ 300，1 ≤ <em>c</em> ≤ 50；<br>　　对于所有评测用例，1 ≤ <em>N</em>, <em>K</em> ≤ 1000，1 ≤ <em>w</em> ≤ <em>N</em>，1 ≤ <em>s</em> ≤ 10000，1 ≤ <em>c</em> ≤ 100。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>用到两个结构体，保存每次取用的3个数据分别按取出时间和返还时间的排序，即按时间顺序排列。</p>
<p>vector使用sort排序时写法是<code>sort(v.begin(),v.begin()+v.size());</code>。</p>
<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> no,s,en;  <span class="comment">//no号钥匙，s时刻借出，en时刻返还 </span></span><br><span class="line">&#125;node[<span class="number">1005</span>],node1[<span class="number">1005</span>];  <span class="comment">//分别对s和en排序 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//按开始时间排序（相同的话再按钥匙号排序 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Node <span class="keyword">const</span> &amp;a, Node <span class="keyword">const</span> &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.s==b.s)&#123;</span><br><span class="line">		<span class="keyword">return</span> a.no&lt;b.no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a.s&lt;b.s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按返还时间排序（相同的话再按钥匙号排序 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Node <span class="keyword">const</span> &amp;a, Node <span class="keyword">const</span> &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.en==b.en)&#123;</span><br><span class="line">		<span class="keyword">return</span> a.no&lt;b.no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a.en&lt;b.en;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> order[<span class="number">1005</span>];  <span class="comment">//oder[i]=x表示第i号钥匙挂在x号钩上 </span></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1005</span>];  <span class="comment">//ans[x]=i表示第x号钩子挂着i号钥匙 </span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">//处理钥匙的移出和挂回 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> N,K;  <span class="comment">//N把钥匙，K次取还 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;K);</span><br><span class="line">	<span class="comment">//初始时，i号钥匙挂于i号钩	</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		order[i]=i;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//读入i次取还 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;node[i].no, &amp;node[i].s,&amp;node[i].en);</span><br><span class="line">		node[i].en += node[i].s;</span><br><span class="line">		node1[i] = node[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//分别对s和en排序</span></span><br><span class="line">	<span class="built_in">sort</span>(node,node+K,cmp1);</span><br><span class="line">	<span class="built_in">sort</span>(node1,node1+K,cmp2);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* //打印排序结果 </span></span><br><span class="line"><span class="comment">	cout&lt;&lt;&quot;****&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">	for(int i=0;i&lt;K;i++)&#123;</span></span><br><span class="line"><span class="comment">		cout&lt;&lt;node[i].s&lt;&lt;&#x27; &#x27;&lt;&lt;node[i].no&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	cout&lt;&lt;&quot;****&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">	for(int i=0;i&lt;K;i++)&#123;</span></span><br><span class="line"><span class="comment">		cout&lt;&lt;node1[i].en&lt;&lt;&#x27; &#x27;&lt;&lt;node1[i].no&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">	&#125; </span></span><br><span class="line"><span class="comment">	cout&lt;&lt;&quot;****&quot;&lt;&lt;endl;*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> f1=<span class="number">0</span>, f2=<span class="number">0</span>;  <span class="comment">//表示借出和返还的次数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> time=<span class="number">1</span>;!(f1==K &amp;&amp; f2==K);time++)&#123;  <span class="comment">//借还次数都满时，时间停止，退出循环 		</span></span><br><span class="line">		<span class="comment">//先还 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=f1;i&lt;K;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(node1[i].en &gt; time) <span class="keyword">break</span>;  <span class="comment">//还没到下一把钥匙的返还时间 			</span></span><br><span class="line">			<span class="keyword">if</span>(node1[i].en == time)&#123;</span><br><span class="line">				order[node1[i].no] = v[<span class="number">0</span>];  <span class="comment">//取出v中的第一个元素(即最小的编号)</span></span><br><span class="line">				v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());  <span class="comment">//并将第一个元素删除</span></span><br><span class="line">				<span class="comment">//cout&lt;&lt;node1[i].no&lt;&lt;&quot; 号钥匙放回 &quot;&lt;&lt;order[node1[i].no]&lt;&lt;endl;</span></span><br><span class="line">			&#125;</span><br><span class="line">			f1++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//再借</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=f2;i&lt;K;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].s &gt; time)<span class="keyword">break</span>;	 <span class="comment">//还没到下一把钥匙的借出时间 		</span></span><br><span class="line">			<span class="keyword">if</span>(node[i].s == time)&#123;</span><br><span class="line">				v.<span class="built_in">push_back</span>(order[node[i].no]);  <span class="comment">//保存被取出的钥匙的空位</span></span><br><span class="line">				<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">begin</span>()+v.<span class="built_in">size</span>());  <span class="comment">//对所有空钩排序</span></span><br><span class="line">				order[node[i].no]=<span class="number">0</span>;</span><br><span class="line">				<span class="comment">//cout&lt;&lt;node[i].no&lt;&lt;&quot; 号钥匙已拿走... &quot;&lt;&lt;endl;		</span></span><br><span class="line">			&#125; </span><br><span class="line">			f2++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		ans[order[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OJ</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>结构体排序</tag>
      </tags>
  </entry>
  <entry>
    <title>时序动作定位综述（强监督）</title>
    <url>/TALsurvey/</url>
    <content><![CDATA[<h1 id="时序动作定位（Temporal-Action-Localization）总结"><a href="#时序动作定位（Temporal-Action-Localization）总结" class="headerlink" title="时序动作定位（Temporal Action Localization）总结"></a>时序动作定位（Temporal Action Localization）总结</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在视频序列中确定动作发生的<u><strong>时间区间</strong></u>（包括开始时间与结束时间）以及动作的<u><strong>类别</strong></u>。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按阶段分：</p>
<ul>
<li>多阶段方法：S-CNN、BSN、BMN……</li>
<li>端到端方法：SSAD、SS-TAD、GTAN、DBG……</li>
</ul>
<p>按监督分：</p>
<ul>
<li>强监督方法：以上都是</li>
<li>弱监督方法：UntrimmedNet、STPN、CMCS、Background Modeling、BaSNet……</li>
</ul>
<h2 id="基准数据集"><a href="#基准数据集" class="headerlink" title="基准数据集"></a>基准数据集</h2><p>最流行的是THUMOS14和ActivityNet。</p>
<h2 id="两阶段方法"><a href="#两阶段方法" class="headerlink" title="两阶段方法"></a>两阶段方法</h2><p>两阶段方法即先<strong>提议</strong>后<strong>分类</strong>。这种方法是主流的方法（多数论文都采用）。</p>
<ol>
<li>提取temporal proposals（难点）</li>
<li>将其分类以及回归操作</li>
</ol>
<p>第一步是难点，所以各种方法也都是针对第一步来提出。</p>
<p>对于两阶段的方案存在的<strong>问题</strong>：</p>
<ol>
<li>由于对候选片段的生成和分类是相对独立的，各个模块<strong>训练目标不一致</strong>；</li>
<li>动作实例的候选片段在分类步骤中已经被固定，前一模块产生的偏差可能影响后一个模块，造成<strong>误差的累积</strong>。</li>
</ol>
<h3 id="SLIDING-WINDOW-S-CNN-2016"><a href="#SLIDING-WINDOW-S-CNN-2016" class="headerlink" title="SLIDING WINDOW (S-CNN, 2016)"></a>SLIDING WINDOW (S-CNN, 2016)</h3><p><img src="image-20210927182540574.png" alt="image-20210927182540574" style="zoom: 67%;" /></p>
<p>S-CNN：<strong>固定一定大小的滑动窗口</strong>来生成不同大小的视频片段，然后通过多级网络(SegmentCNN)对其进行处理。</p>
<p>SCNN包括三个使用C3D网络的子网络：</p>
<ol>
<li>proposal网络。确定当前划分的视频片段（segment）是一个动作（action）的可能性。</li>
<li>分类网络。对视频片段进行分类。</li>
<li>定位网络。其输出是分类的概率。</li>
</ol>
<p>理论上，窗口滑动的重叠度越高，效果越好，但是计算量也大。所以用非极大值抑制（NMS）去除重叠段。</p>
<p><strong>缺点</strong>：滑窗法不能处理不同长度的视频动作；密集的滑窗计算量太大。</p>
<h3 id="时序动作组合-TEMPORAL-ACTIONNESS-GROUPING-TAG-2017"><a href="#时序动作组合-TEMPORAL-ACTIONNESS-GROUPING-TAG-2017" class="headerlink" title="时序动作组合 TEMPORAL ACTIONNESS GROUPING (TAG, 2017)"></a>时序动作组合 TEMPORAL ACTIONNESS GROUPING (TAG, 2017)</h3><p><img src="/image-20210927182821079.png" alt="image-20210927182821079" style="zoom:67%;" /></p>
<p>滑窗法不能处理不同长度的视频动作。为了生成一个proposal，提出了TAG网络。TAG网络分为3步：</p>
<ol>
<li>提取片段（snippets）：每个snippet包含一个视频帧和光流（ optical flow）信息；snippet是均匀获取的；用TSN的稀疏采样方法采样。</li>
<li><p>动作判断（Actionness）：给snippet打分，确定每个snippet是否含有任何动作。用到二分类网络TSN（Temporal Segment Network）。</p>
</li>
<li><p>组合（Grouping）：依据输出的snippets序列的概率，对高概率的连续snippets进行组合，同时设置多组阈值来删除低概率的snippets。</p>
</li>
</ol>
<p>在THUMOS2014上IOU=0.5时候MAP=28.25。</p>
<p>优点：对边界的处理更灵活；减少了proposal数目，减少计算量；合并片段是自底向上的，更加精确；设置多个阈值组合，可以不需改变参数的训练。</p>
<p><strong>缺点</strong>：分类错误的话，会错过一些proposal。</p>
<h3 id="时序单元回归网络-TEMPORAL-UNIT-REGRESS-NETWORK-TURN-TAP-2017"><a href="#时序单元回归网络-TEMPORAL-UNIT-REGRESS-NETWORK-TURN-TAP-2017" class="headerlink" title="时序单元回归网络 TEMPORAL UNIT REGRESS NETWORK (TURN TAP 2017)"></a>时序单元回归网络 TEMPORAL UNIT REGRESS NETWORK (TURN TAP 2017)</h3><p><img src="/TURN-TAP.jpg" alt=""></p>
<p>该方法将视频分成固定大小的单元（unit），例如16帧为一单元。然后将每个单元放入C3D中提取水平特征。相邻单元构成一个片段（clip），并让每个单元作为锚定单元（anchor unit）构成片段金字塔，然后在单元上执行时序坐标回归。</p>
<p>网络包含两个输出：</p>
<ol>
<li>确定片段（clip）是否包含动作的置信度</li>
<li>调整时序坐标边界的偏移量</li>
</ol>
<p>该方法的贡献：</p>
<ol>
<li>一种利用坐标回归生成时序proposal片段的新方法。</li>
<li>快（800fps）。</li>
<li>提出了一种新的评价指标AR-F。</li>
</ol>
<h3 id="边界敏感网络-BOUNDARY-SENSITIVE-NETWORK-BSN-2018"><a href="#边界敏感网络-BOUNDARY-SENSITIVE-NETWORK-BSN-2018" class="headerlink" title="边界敏感网络 BOUNDARY SENSITIVE NETWORK (BSN, 2018)"></a>边界敏感网络 BOUNDARY SENSITIVE NETWORK (BSN, 2018)</h3><p><img src="/image-20210927185640495.png" alt="image-20210927185640495"></p>
<p>BSN步骤：</p>
<ol>
<li>首先确定时序动作片段的边界，并将其此片段直接作为proposal。</li>
<li>对每个候选proposal，基于动作序列的置信度，提取32维的proposal级别的特征。</li>
<li>最后，根据所提取的这些特征，评估这些proposal的置信度。</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><strong>框架</strong>：提出了一种全新的且非常有效的时序提名生成框架，能够产生满足(1)时长灵活(2)边界准确(3)评分可靠的时序动作提名；</li>
<li><strong>灵活性</strong>：BSN方法的模块非常简单且灵活，能够灵活地应用于不同的垂类场景。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>效率不够高</strong>：提名特征提取以及置信度评估的过程是对每个时序提名逐个进行的，虽然可以在一定程度上做并行加速，但总体上还是效率比较差；</li>
<li><strong>语义信息丰富性不足</strong>：为了保证提名特征提取过程的效率，BSN中所设计的32维提名特征是比较简单的，但也限制了置信度评估模块从特征中获得更加丰富的语义信息；</li>
<li><strong>多阶段</strong>：BSN方法是一个多阶段的方法，没有将几部分网络联合优化。</li>
</ul>
<h3 id="边界匹配网络-BOUNDARY-MATCHING-NETWORK-BMN-2019"><a href="#边界匹配网络-BOUNDARY-MATCHING-NETWORK-BMN-2019" class="headerlink" title="边界匹配网络 BOUNDARY-MATCHING NETWORK (BMN, 2019)"></a>边界匹配网络 BOUNDARY-MATCHING NETWORK (BMN, 2019)</h3><p>为了解决BSN的不足所提出。BMN网络能够同时生成与BSN中类似的一维边界概率序列，以及二维的BM置信度图来密集的评估所有可能存在的时序提名的置信度分数。</p>
<p>右下角三角形区域的解释：提名的结束时间超出了视频的范围，不被纳入考虑。</p>
<p><img src="/image-20211213220303917.png" alt="image-20211213220303917" style="zoom: 67%;" /></p>
<p>BMN主要包括3个模块：</p>
<ul>
<li>基础模块：包括两个1d卷积层，处理输入的特征序列，并输出被后续两个模块所共享的时序特征序列。</li>
<li>时序评估模块：包含两个1d卷积层，输出<u>开始概率序列</u>和<u>结束概率序列</u>，用于后续的提名生成。</li>
<li>提名评估模块：包含了前面介绍的BM layer，一个3d卷积层以及3个2d卷积层，最终输出为BM置信度图。</li>
</ul>
<p>网络生成时序边界概率序列后，产生候选时序提名；并从二维置信度图中取出对应的置信度分数，用于最后的时序提名排序。</p>
<p>最后用了Soft-NMS方法去除冗余结果。</p>
<p><strong>优点：</strong>效率比BSN更高；</p>
<h2 id="一阶段（端到端）方法"><a href="#一阶段（端到端）方法" class="headerlink" title="一阶段（端到端）方法"></a>一阶段（端到端）方法</h2><p>这种方法同时处理proposal和分类。</p>
<h3 id="End-to-end-Learning-of-Action-Detection-from-Frame-Glimpses-in-Videos-2016-CVPR"><a href="#End-to-end-Learning-of-Action-Detection-from-Frame-Glimpses-in-Videos-2016-CVPR" class="headerlink" title="End-to-end Learning of Action Detection from Frame Glimpses in Videos [2016 CVPR]"></a>End-to-end Learning of Action Detection from Frame Glimpses in Videos [2016 CVPR]</h3><p>视频动作检测任务中的<u>第一个</u>端到端方法。用了强化学习的思路。</p>
<p>该模型有一个基于递归神经网络的agent，它随着时间的推移与视频交互。agent观察固定比例的视频帧，并决定下一步在哪里看以及何时发出预测。</p>
<p><img src="/image-20211008105534974.png" alt="image-20211008105534974"></p>
<p><strong>总体流程</strong></p>
<p>在某一步n中，agent观察橙色视频帧并产生3个输出：$(d_n, p_n, l_{n+1})$，分别表示（候选检测结果，预测指标，下一处观察位置）。其中，预测指标$p_n$输出“是”或“否”，指示$d_n$可否被作为一个预测结果被提交；候选检测结果$d_n$包括$(s_n, e_n, c_n)$，分别表示正则化开始、结束位置和该候选的置信度。</p>
<p>在上图中，$p_n$输出“否”，因此不被动作预测集接受。同时agent在n+1步中移动到$l_{n+1}$的位置，即绿色视频帧的位置，并继续产生3个输出：$(d_{n+1}, p_{n+1}, l_{n+2})$。此时$p_{n+1}$仍不被接受，因此agent在n+2步中移动到$l_{n+2}$的位置，即蓝色视频帧的位置。这次的$p_{n+2}$被接受，因此将该候选结果输入到动作预测集，同时agent继续下一步。</p>
<p><strong>优点：</strong>只需要观察很少数的视频帧（2%甚至更少）</p>
<h3 id="SSAD（single-shot-temporal-action-detection，单镜头时序动作检测）"><a href="#SSAD（single-shot-temporal-action-detection，单镜头时序动作检测）" class="headerlink" title="SSAD（single shot temporal action detection，单镜头时序动作检测）"></a>SSAD（single shot temporal action detection，单镜头时序动作检测）</h3><p>结合了在目标检测中的YOLO和SSD模型的特性。</p>
<p><img src="image-20220115231850631.png" alt="image-20220115231850631"></p>
<p><strong>缺点：</strong>虽然不是像S-CNN那样固定了滑窗，但是bbox的大小实际上还是由人为事先规定的；效率可能不是很高，因为会生成很多的bbox。</p>
<h3 id="SS-TAD（end-to-end-single-stream-temporal-action-detection，端到端，单流时序动作检测）"><a href="#SS-TAD（end-to-end-single-stream-temporal-action-detection，端到端，单流时序动作检测）" class="headerlink" title="SS-TAD（end-to-end, single-stream temporal action detection，端到端，单流时序动作检测）"></a>SS-TAD（end-to-end, single-stream temporal action detection，端到端，单流时序动作检测）</h3><p>利用时序动作定位的语义子任务作为调整后的<strong>语义约束</strong>（semantic constraints）来提高训练和测试性能。</p>
<p><img src="/image-20211011161132357.png" alt="image-20211011161132357"></p>
<p><strong>优点：</strong>效率上比SSAD更好。</p>
<h3 id="GTAN（Gaussian-Temporal-Awareness-Networks，高斯时序感知网络）"><a href="#GTAN（Gaussian-Temporal-Awareness-Networks，高斯时序感知网络）" class="headerlink" title="GTAN（Gaussian Temporal Awareness Networks，高斯时序感知网络）"></a>GTAN（Gaussian Temporal Awareness Networks，高斯时序感知网络）</h3><p>引入高斯核函数（Gaussian kernels），动态优化每个动作proposal的时序范围。</p>
<p><img src="/image-20211101210605894.png" alt="image-20211101210605894"></p>
<h2 id="弱监督方法"><a href="#弱监督方法" class="headerlink" title="弱监督方法"></a>弱监督方法</h2><p>见另一个文件。</p>
<h2 id="总结和想法"><a href="#总结和想法" class="headerlink" title="总结和想法"></a>总结和想法</h2><ul>
<li>通过梳理和总结，现在对各种好的思路和方法有了比较清晰的了解。</li>
</ul>
<ul>
<li>端到端的时序动作定位方法</li>
</ul>
<p>从目标检测的发展进程来看，在目标检测算法的发展与落地应用过程中，往往单阶段算法可以在推理速度与模型大小中有着更大的优势。模型结构也往往更加简单。</p>
<p>多阶段的方法往往由多个独立的模块组成，每个步骤结果的好坏会影响到下一步骤，从而影响训练结果，同时需要较为高昂的标注成本，因此端到端的方法更具有实用价值。现有的方法中，两阶段的方法，如R-C3D，评估不同尺度的proposal用的是共享特征，而时间段的范围和anchor的跨度不对齐，难以解决时间段的变化比目标检测的区域变化范围更大的问题。聚合动作性分数的方法，如SSN，TAG，ETP，CTAP由于其感受野的限制，会使得在时间跨度较大的数据集上表现不佳。基于边界的方法，如BSN，BMN，BSN++需要先使用骨干网络提取视频中的特征，保存后再使用特征进行训练和测试，并且只产生proposal在实际应用中价值有限。</p>
<ul>
<li>弱监督的时序动作定位方法</li>
</ul>
<p>弱监督时序动作定位的标签只提供实例的类别信息，需要网络自身去猜测动作的起止时间，问题定义更加复杂，但是实用价值更高，因此有不少研究人员将目光聚焦于弱监督时序动作定位中。主流的弱监督时序动作定位算法通过预测视频片段的动作概率，通过融合得到整个视频的概率输出，然后通过注意力模型得到每个视频片段对应的注意力权重。在测试阶段，通过注意力权重筛选视频片段，去除不包括动作的片段。</p>
<ul>
<li>充分利用上下文信息</li>
</ul>
<p>在时序动作定位任务中，视频包含丰富的上下文信息。如在背景片段中，往往包含场景信息，充分利用上下文信息将有助于对应场景动作的检测。</p>
<p>为了充分利用上下文的信息，一些方法如TCANet，BSN++，使用自注意力对时序以及空间关系建模，寻找特征的全局依赖关系，自注意力模块会<strong>消耗大量的计算资源</strong>，降低方法的实用性。一些方法，如TCN,TURN,TSN，按照<strong>预定义比例扩展动作时间边界</strong>以利用视频上下文信息，TAL-net使用空洞卷积编码上下文信息,但这些方法只是简单的利用了时序方向的上下文，在动作的时序领域中扩展边界，现实中的动作在时间范围，动作内容都有较大差异，这些方法无法充分利用视频中丰富的上下文信息。另一部分方法如P-GCN，使用图卷积网络学习proposal之间的依赖关系，在生成proposal时使用了聚合动作性分数的方法，存在<strong>感受野受限</strong>的问题。</p>
<h2 id="下周计划"><a href="#下周计划" class="headerlink" title="下周计划"></a>下周计划</h2><ul>
<li>周一又开学了，不在校也要尽量保持在校的状态。</li>
<li>这学期有些好的论文虽然看过了，但是还没有来得及做实验。继续写代码做实验。</li>
<li>继续调研综述中提到的那些思路和方法。</li>
</ul>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
        <tag>综述</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测算法</title>
    <url>/cl5gc8axm001xecu9goasdrbv/</url>
    <content><![CDATA[<h1 id="一阶段（端到端）方法"><a href="#一阶段（端到端）方法" class="headerlink" title="一阶段（端到端）方法"></a>一阶段（端到端）方法</h1><h2 id="YOLO"><a href="#YOLO" class="headerlink" title="YOLO"></a>YOLO</h2><p>原论文：《You Only Look Once: Unified, Real-Time Object Detection》</p>
<p>Yolo算法采用一个单独的CNN模型实现end-to-end的目标检测。</p>
<span id="more"></span>
<p>Yolo的CNN网络将输入的图片分割成$ S × S $个单元格，每个单元格负责去检测那些中心点落在该格子内的目标（举个例子：狗的中心落在左下角一个单元格内，那么该单元格负责预测这个狗），每个单元格会预测$B$个边界框<u>bbox</u>（bounding box）及该bbox的<u>置信度</u>（confidence）。如果一个bbox中不含目标，那么其置信度 = 0；如果包含目标，那么置信度 = bbox与实际框（GT）的IOU。</p>
<p>边界框的大小与位置可以用4个值来表征，加上置信度，每个边界框的预测值实际上包含$5$个元素：$(x, y, w, h, c)$。</p>
<p><img src="image-20211009172445920.png" alt="image-20211009172445920"></p>
<p><strong>分类：</strong>在Yolo算法中，一个单元格内的多个bbox都被预测为同一个类别（这是Yolo算法的一个<strong>缺点</strong>，因为这样很容易漏掉小目标），所以对于每一个单元格，会给出置信度最高的那个bbox的$C$个类别的概率值。</p>
<p>综上，每个单元格需要预测$(B <em> 5 + C)$个值，如果有$ S × S $个单元格，那么最终预测值为$S × S×(B </em> 5 + C)$大小的张量。</p>
<p><strong>Yolo的缺点</strong>：定位不准；难以检测小目标。</p>
<h2 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h2><p>相比Yolo，SSD采用CNN来直接进行检测，而不是像Yolo那样在全连接层之后做检测。</p>
<p>另外还有两个重要的改变，一是SSD提取了不同尺度的特征图来做检测，大尺度特征图（较靠前的特征图）可以用来检测小物体，而小尺度特征图（较靠后的特征图）用来检测大物体；二是SSD采用了不同尺度和长宽比的先验框（Prior boxes, Default boxes，在Faster R-CNN中叫做锚，Anchors）。</p>
<p><img src="/image-20211012173044143.png" alt="image-20211012173044143"></p>
<h3 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h3><h4 id="（1）采用多尺度特征图用于检测"><a href="#（1）采用多尺度特征图用于检测" class="headerlink" title="（1）采用多尺度特征图用于检测"></a>（1）采用多尺度特征图用于检测</h4><p>所谓多尺度，就是采用大小不同的特征图。大尺度特征图（较靠前的特征图）可以用来检测小物体，而小尺度特征图（较靠后的特征图）用来检测大物体。</p>
<h4 id="（2）采用卷积进行检测"><a href="#（2）采用卷积进行检测" class="headerlink" title="（2）采用卷积进行检测"></a>（2）采用卷积进行检测</h4><p>与Yolo最后采用全连接层不同，SSD直接采用卷积对不同的特征图来进行提取检测结果。对于形状为 m <em> n </em> p 的特征图，只需要采用 3 <em> 3 </em> p  这样比较小的卷积核得到检测值。</p>
<h4 id="（3）设置先验框"><a href="#（3）设置先验框" class="headerlink" title="（3）设置先验框"></a>（3）设置先验框</h4><p>SSD借鉴了Faster R-CNN中anchor的理念，每个单元设置尺度或者长宽比不同的先验框，预测的边界框（bounding boxes）是以这些先验框为基准的，在一定程度上减少训练难度。</p>
<p>每个单元会设置多个先验框，其尺度和长宽比存在差异，如下图所示，可以看到每个单元使用了4个不同的先验框，图片中猫和狗分别采用最适合它们形状的先验框来进行训练。</p>
<p><img src="image-20211009223547399.png" alt="image-20211009223547399"></p>
<p>综上所述，对于一个大小  m <em> n  的特征图，共有 m </em> n 个单元，每个单元设置的先验框数目记为  k ，那么每个单元共需要 (c + 4) <em> k 个预测值，所有的单元共需要  (c + 4) </em> k <em> m </em> n个预测值，由于SSD采用卷积做检测，所以就需要 (c + 4) * k 个卷积核完成这个特征图的检测过程。</p>
]]></content>
      <categories>
        <category>目标检测算法</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
        <tag>YOLO</tag>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title>c++：STL</title>
    <url>/cppstl/</url>
    <content><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt; stu;  <span class="comment">// 定义一个map对象</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt;::iterator it;  <span class="comment">//定义相应的迭代器（用于遍历）</span></span><br><span class="line"><span class="comment">//插入元素：用&quot;array&quot;方式插入</span></span><br><span class="line">stu[<span class="number">123</span>] = <span class="string">&quot;student_first&quot;</span>;</span><br><span class="line">stu[<span class="number">456</span>] = <span class="string">&quot;student_second&quot;</span>;</span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">for</span>(it=stu.<span class="built_in">begin</span>();it!=stu.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout&lt;&lt;it-&gt;first;    <span class="comment">//first表示key</span></span><br><span class="line">    cout&lt;&lt;it-&gt;second;    <span class="comment">//second表示value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	map.count(Key)返回值为1或者0，1返回存在，0返回不存在。因为在map中数据的Key值都是不同的，所以被count的数要么存在1次，要么不存在。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	begin()指向第一个元素</span></span><br><span class="line"><span class="comment">	end()指向最后一个元素的后一个元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set即数学上的集合——每个元素最多只出现一次。</p>
<h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1.头文件"></a>1.头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2.常用操作"></a>2.常用操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; s	</span><br><span class="line">    </span><br><span class="line">s.<span class="built_in">size</span>()	<span class="comment">//集合中元素的数目</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">clear</span>()	<span class="comment">//清除所有元素</span></span><br><span class="line">s.<span class="built_in">count</span>()	<span class="comment">//返回某个值元素的个数</span></span><br><span class="line">s.<span class="built_in">empty</span>()	<span class="comment">//如果集合为空，返回true</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">begin</span>()	<span class="comment">//返回指向第一个元素的迭代器</span></span><br><span class="line">s.<span class="built_in">end</span>()		<span class="comment">//返回指向最后一个元素之后的迭代器，不是最后一个元素</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">erase</span>()	<span class="comment">//删除集合中的元素</span></span><br><span class="line">s.<span class="built_in">find</span>()	<span class="comment">//返回一个指向被查找到元素的迭代器，如果没找到则返回end()</span></span><br><span class="line">s.<span class="built_in">insert</span>()	<span class="comment">//在集合中插入元素</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">swap</span>()	<span class="comment">//交换两个集合变量</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">lower_bound</span>(要查找的数值)    <span class="comment">//返回的是数值  第一个  出现的位置</span></span><br><span class="line">s.<span class="built_in">upper_bound</span>(要查找的数值)    <span class="comment">//返回的是数值 最后一个 出现的位置</span></span><br></pre></td></tr></table></figure>
<h2 id="3-例子："><a href="#3-例子：" class="headerlink" title="3.例子："></a>3.例子：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入10个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印10个元素</span></span><br><span class="line">    <span class="keyword">for</span>(it=s.<span class="built_in">begin</span>(); it!=s.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">insert</span>(<span class="number">3</span>).second)<span class="comment">//把3插入到s中,插入成功则s.insert(3).second返回1，否则返回0.</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;插入成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;插入失败&quot;</span>&lt;&lt;endl;  <span class="comment">// √</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(it=s.<span class="built_in">begin</span>(); it!=s.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">pop_back</span>();       <span class="comment">// 删除最后一个数据。</span></span><br><span class="line">c.<span class="built_in">push_back</span>(elem);  <span class="comment">// 在尾部加入一个数据。</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">front</span>()     <span class="comment">// 传回第一个数据</span></span><br><span class="line">c.<span class="built_in">back</span>()      <span class="comment">// 传回最后一个数据</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">erase</span>(pos)  <span class="comment">// 删除pos位置的数据，传回下一个数据的位置。</span></span><br><span class="line">c.<span class="built_in">insert</span>(pos,elem)    <span class="comment">// 在pos位置插入一个elem拷贝，传回新数据位置。</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">size</span>()		<span class="comment">// 返回容器中实际数据的个数。</span></span><br><span class="line">c.<span class="built_in">resize</span>(num)	<span class="comment">// 改变vector大小</span></span><br><span class="line">c.<span class="built_in">clear</span>()		<span class="comment">// 移除容器中所有数据。</span></span><br><span class="line">c.<span class="built_in">empty</span>()		<span class="comment">// 判断容器是否为空。</span></span><br></pre></td></tr></table></figure>
<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">queue&lt;<span class="keyword">double</span>&gt; q2;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(x);  <span class="comment">//将x 接到队列的末端。</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">//弹出队列的第一个元素，注意，没有返回值！</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">front</span>(); <span class="comment">//即最早被压入队列的元素。</span></span><br><span class="line">q.<span class="built_in">back</span>(); <span class="comment">//即最后被压入队列的元素。</span></span><br><span class="line"></span><br><span class="line">q.<span class="built_in">size</span>();  </span><br><span class="line">q.<span class="built_in">empty</span>();  <span class="comment">//当队列空时，返回true。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若要取完队头元素后删之，需front()和pop()连用</span></span><br></pre></td></tr></table></figure>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>优先队列有点像队列，但优先队列的出队元素，不是最先进队的元素，而是优先级最高的元素。（这样就可以允许类似“急诊病人插队”这样的事情发生。）</p>
<p>由于不是先进先出，所以出队的方法由<code>front()</code>变为<code>top()</code>。</p>
<p>自定义类型也可以组成优先队列，但必须为每个元素定义一个优先级（这个“优先级”只需要能比较大小即可）。</p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq;		<span class="comment">//越大的整数优先级越高</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文笔记】【动作检测】SlowFast Networks for Video Recognition</title>
    <url>/slowfast/</url>
    <content><![CDATA[<h1 id="SlowFast-Networks-for-Video-Recognition"><a href="#SlowFast-Networks-for-Video-Recognition" class="headerlink" title="SlowFast Networks for Video Recognition"></a>SlowFast Networks for Video Recognition</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>提出了一种快慢结合的网络<strong>SlowFast</strong>来用于视频分类。提出对<u>运动维度（时间维度）</u>和<u>空间维度</u>分而治之的思想。</p>
<p><strong>灵感来源：</strong></p>
<ul>
<li>空间语义信息是变化缓慢的。比如，挥手不会改变“手”的类别；一个人从步行转为跑步，也总是处于“人”的类别。因此，对分类语义（以及它们的颜色、纹理、光照等）的识别可以低帧率地刷新。</li>
<li>但对于正在执行的动作，可以比其主体身份更快地发展，例如拍手，挥手，摇晃，行走或跳跃。所以采用高帧率来有效地模拟可能快速变化的运动。</li>
</ul>
<p>模型分为两路：</p>
<ul>
<li>一路为Slow网络，输入为低帧率，用来捕获<strong>空间</strong>语义信息。</li>
<li>一路为Fast网络，输入为高帧率，用来捕获<strong>运动</strong>信息。</li>
</ul>
<p>最终两条路径通过横向连接来融合。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><img src="image-20211115172221627.png" alt="image-20211115172221627"></p>
<h3 id="1-Slow路径"><a href="#1-Slow路径" class="headerlink" title="1. Slow路径"></a>1. Slow路径</h3><p>输入为低帧率，用来捕获<strong>空间</strong>语义信息。</p>
<p>对于一个视频片段，Slow网络每隔 <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="[公式]"> 帧（默认=16）采样一帧作为输入。假定该网络的输入为<em>T</em> 帧，则该视频片段的长度为<img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=%5Ctimes" alt="[公式]"> <em>T</em> 。</p>
<h3 id="2-Fast路径"><a href="#2-Fast路径" class="headerlink" title="2. Fast路径"></a>2. Fast路径</h3><p>对比Slow路径，有两个重要参数α和β。</p>
<ul>
<li><p><em>高帧率：</em>Fast网络相比于Slow网络，处理高帧率的信息，则每 <img src="https://www.zhihu.com/equation?tex=%5Ctau%2F%5Calpha" alt="[公式]"> 帧采样一帧作为输入，也就是输入为 <img src="https://www.zhihu.com/equation?tex=%5Calpha+T" alt="[公式]"> 帧。 （<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="[公式]"> =8 默认)</p>
</li>
<li><p><em>高分辨率的时序特征：</em>不进行时间的降采样。（始终保持高帧率）</p>
</li>
<li><p><em>轻量级：</em>相比于Slow网络，通道数只是它的 <img src="https://www.zhihu.com/equation?tex=%5Cbeta" alt="[公式]"> 倍（<img src="https://www.zhihu.com/equation?tex=%5Cbeta" alt="[公式]">&lt;1，文中取1/8）。一般计算复杂度（FLOPs)与通道数为二次关系（why？)，所以在SlowFast中，Fast网络占到20%左右的计算量。</p>
</li>
</ul>
<p>虽然Fast是高帧率的，但它却是轻量的（只占总计算量的20%），因为Fast路径只专注于时序信息，减少了通道数，牺牲了处理空间信息的能力。而空间信息可以由slow路径提供。</p>
<h3 id="3-横向连接"><a href="#3-横向连接" class="headerlink" title="3. 横向连接"></a>3. 横向连接</h3><p>两条路径需要进行融合，通过横向连接来实现这一点。因为两路具有不同的时间维度，因此横向连接进行尺寸匹配。</p>
<p>使用单向连接将Fast路径的特征融合到Slow通路中（实验表明双向融合并没有什么提升）。</p>
<p>最后，对每个路径的输出进行全局平局池化，合并后接一个全连接层用来分类。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>在四个数据集(Kinetics400 、Kinetics600 、AVA、Charades )上都取得了最好的结果。</p>
<p><strong>消融实验</strong></p>
<p><img src="image-20211115192138885.png" alt="image-20211115192138885"></p>
<p><img src="image-20211115195412692.png" alt="image-20211115195412692"></p>
<h2 id="和two-stream网络的比较"><a href="#和two-stream网络的比较" class="headerlink" title="和two-stream网络的比较"></a>和two-stream网络的比较</h2><ul>
<li><p>two-stream模型也是双流设计，但它针对的是相同的帧率。</p>
</li>
<li><p>two-stream的两个流采用相同的主干结构，而SlowFast两条路中的Fast路径更轻。</p>
</li>
<li>SlowFast方法不计算光流，模型是从原始数据端到端学习的。</li>
<li>本文的实验表明SlowFast 网络更有效，在四个数据集(Kinetics400 、Kinetics600 、AVA、Charades )上都实现了最高的水准。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在时间维度上更好地处理运动信息，是一个重点研究问题。</li>
<li>有没有时序动作定位论文用这个网络来提取特征？</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>论文笔记</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
        <tag>动作检测</tag>
      </tags>
  </entry>
</search>
